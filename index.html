<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Stay Hungry, Stay Foolish">
<meta name="keywords" content="test">
<meta property="og:type" content="website">
<meta property="og:title" content="Leesine&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Leesine&#39;s Blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leesine&#39;s Blog">
<meta name="twitter:description" content="Stay Hungry, Stay Foolish">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Leesine's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leesine's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/19/ceph-monx-paxos/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/19/ceph-monx-paxos/" itemprop="url">ceph-mon paxos实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-19T20:00:11+08:00">
                2019-07-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Monitor是Ceph集群中的元数据管理组件，负责整个集群的元信息的维护，这里的元信息主要是几张抽象的map，包括osdmap、pgmap、monmap、mdsmap等。在Ceph集群中，OSD的设计原型为INTELLIGENT STORAGE DEVICES，通过这种智能的OSD可以减少Monitor作为中心节点的负担。在实际运行过程中，真正需要Monitor介入的主要是以下几种场景：</p>
<ul>
<li>Client在首次访问时需要从Monitor处获取集群crush map信息</li>
<li>OSD节点会向Monitor节点汇报故障OSD的信息，Monitor需要修改对应map</li>
<li>OSD在加入集群时，会向Monitor发送信息，Monitor需要修改对应map</li>
</ul>
<p>整体来说，Monitor是基于改进的Paxos算法，对外提供一致的元信息访问及更新服务。</p>
<h2 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a>PAXOS</h2><p><img src="/images/12.png" alt=""></p>
<p>Monitor的整体架构如上图所示，整体分为4层，分别是DB层、Paxos层、PaxosService层及应用层。DB层用于提供单机KV存储服务，而PaxosService将应用层的不同元信息操作层封装成KV操作下发至Paxos层，Paxos层对上层提供一致性的KV存储服务，上层的不同PaxosService都共用一个Paxos实例。下面来看Paxos层是如何基于改进的Paxos算法来对外提供服务的。</p>
<p>Monitor中主要有两个角色，分别是leader及peon，其中只有leader能发提案，即leader对应于paxos中的proposer，peon及leader都是作为paxos中的acceptor存在，只要Monitor集群中半数以上<br>的节点存活，Monitor就能正常对外提供服务。下面先不看leader选举及异常恢复机制，<br>下面通过源码来看一个正常运行Monitor集群中paxos层是如何工作的。</p>
<p>一个paxos实例存在如下可能的状态：</p>
<ul>
<li>recovering：恢复状态，用于选主后各个实例之间的数据同步</li>
<li>active：空闲状态，可以进入新的paxos流程</li>
<li>updating：处于提案commit阶段</li>
<li>updating-previous：恢复数据期间，实例处于提案commit阶段</li>
<li>writing：提案正在写入</li>
<li>writing-previous：恢复数据期间，实例正在写入提案</li>
<li>refresh：等待刷新状态，获取lease后就可进入active状态</li>
<li>shutdown：异常状态</li>
</ul>
<p>一个Paxos实例的正常运行过程主要涉及到如下数据：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//当前实例上保存的最低版本已commit记录</span></span><br><span class="line">  <span class="keyword">version_t</span> first_committed;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//上次提案的proposal number，一个leader在任期间pn是不会变的</span></span><br><span class="line">  <span class="keyword">version_t</span> last_pn;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当前实例上保存的最高版本已commit记录</span></span><br><span class="line">  <span class="keyword">version_t</span> last_committed;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//已accept的最新proposal number</span></span><br><span class="line">  <span class="keyword">version_t</span> accepted_pn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//paxos会将提案的值以Transaction的方式记录在pendping_proposal中，一个Transaction</span></span><br><span class="line">   记录了一系列此次提案对应的操作。从这种形式也能看出来，paxos层一次只能对一个提案进行决议。</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Pending proposal transaction</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This is the transaction that is under construction and pending</span></span><br><span class="line"><span class="comment">   * proposal.  We will add operations to it until we decide it is</span></span><br><span class="line"><span class="comment">   * time to start a paxos round.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  MonitorDBStore::TransactionRef pending_proposal;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//pending_finishers中暂时存放提案被accept后的回调函数</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Finishers for pending transaction</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * These are waiting for updates in the pending proposal/transaction</span></span><br><span class="line"><span class="comment">   * to be committed.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">list</span>&lt;Context*&gt; pending_finishers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//paxos流程开始后，committing_finishers中存放的是提案被选定后的回调函数</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Finishers for committing transaction</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * When the pending_proposal is submitted, pending_finishers move to</span></span><br><span class="line"><span class="comment">   * this list.  When it commits, these finishers are notified.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">list</span>&lt;Context*&gt; committing_finishers;</span><br></pre></td></tr></table></figure></p>
<p>  Paxos的提案入口是在<code>trigger_propose</code>，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">bool</span> Paxos::trigger_propose()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (plugged) &#123;</span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" plugged, not proposing now"</span> &lt;&lt; dendl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_active()) &#123;</span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" active, proposing now"</span> &lt;&lt; dendl;</span><br><span class="line">    propose_pending();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" not active, will propose later"</span> &lt;&lt; dendl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Paxos::propose_pending()</span><br><span class="line">&#123;</span><br><span class="line">  assert(is_active());</span><br><span class="line">  assert(pending_proposal);</span><br><span class="line"></span><br><span class="line">  cancel_events();</span><br><span class="line"></span><br><span class="line">  bufferlist bl;</span><br><span class="line">  pending_proposal-&gt;encode(bl);</span><br><span class="line"></span><br><span class="line">  dout(<span class="number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" "</span> &lt;&lt; (last_committed + <span class="number">1</span>)</span><br><span class="line">	   &lt;&lt; <span class="string">" "</span> &lt;&lt; bl.length() &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; dendl;</span><br><span class="line">  dout(<span class="number">30</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" transaction dump:\n"</span>;</span><br><span class="line">  <span class="function">JSONFormatter <span class="title">f</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">  pending_proposal-&gt;dump(&amp;f);</span><br><span class="line">  f.flush(*_dout);</span><br><span class="line">  *_dout &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  pending_proposal.reset();</span><br><span class="line"></span><br><span class="line">  committing_finishers.swap(pending_finishers);</span><br><span class="line">  state = STATE_UPDATING;</span><br><span class="line">  begin(bl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上源码也可以看出来，一个提案首先是被持久存储在DB中的，这样可以保证提案被被提出后，即使paxos实例异常退出，提案数据也不会丢失。当一个paxos流程开始后，对应的提案会被从DB中取出，并开始决议过程。</p>
<h3 id="begin-leader"><a href="#begin-leader" class="headerlink" title="begin(leader)"></a>begin(leader)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leader</span></span><br><span class="line"><span class="keyword">void</span> Paxos::begin(bufferlist&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  dout(<span class="number">10</span>) &lt;&lt; <span class="string">"begin for "</span> &lt;&lt; last_committed+<span class="number">1</span> &lt;&lt; <span class="string">" "</span> </span><br><span class="line">	   &lt;&lt; v.length() &lt;&lt; <span class="string">" bytes"</span></span><br><span class="line">	   &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//只有leader才能发起提案，并且一次只能由一个提案被决议	   </span></span><br><span class="line">  assert(mon-&gt;is_leader());</span><br><span class="line">  assert(is_updating() || is_updating_previous());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we must already have a majority for this to work.</span></span><br><span class="line">  assert(mon-&gt;get_quorum().size() == <span class="number">1</span> ||</span><br><span class="line">	 num_last &gt; (<span class="keyword">unsigned</span>)mon-&gt;monmap-&gt;size()/<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// and no value, yet.</span></span><br><span class="line">  assert(new_value.length() == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// accept it ourselves</span></span><br><span class="line">  accepted.clear();</span><br><span class="line">  <span class="comment">//accepted列表中插入自身的rank值，因为自己的提案自己是不会拒绝的</span></span><br><span class="line">  accepted.insert(mon-&gt;rank);</span><br><span class="line">  new_value = v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//本次提案为第一个提案</span></span><br><span class="line">  <span class="keyword">if</span> (last_committed == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">t</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;MonitorDBStore::Transaction&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// initial base case; set first_committed too</span></span><br><span class="line">    t-&gt;put(get_name(), <span class="string">"first_committed"</span>, <span class="number">1</span>);</span><br><span class="line">    decode_append_transaction(t, new_value);</span><br><span class="line"></span><br><span class="line">    bufferlist tx_bl;</span><br><span class="line">    t-&gt;encode(tx_bl);</span><br><span class="line"></span><br><span class="line">    new_value = tx_bl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store the proposed value in the store. IF it is accepted, we will then</span></span><br><span class="line">  <span class="comment">// have to decode it into a transaction and apply it.</span></span><br><span class="line">  <span class="comment">//将本次提案存入数据库中，其中key为本次提案版本号，value为提案的值，在提案被选定后，</span></span><br><span class="line">  <span class="comment">//Paxos会将提案读出并使其生效</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">t</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;MonitorDBStore::Transaction&gt;())</span></span>;</span><br><span class="line">  t-&gt;put(get_name(), last_committed+<span class="number">1</span>, new_value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// note which pn this pending value is for.</span></span><br><span class="line">  <span class="comment">//更新当前决议过程中的提案的信息</span></span><br><span class="line">  t-&gt;put(get_name(), <span class="string">"pending_v"</span>, last_committed + <span class="number">1</span>);</span><br><span class="line">  t-&gt;put(get_name(), <span class="string">"pending_pn"</span>, accepted_pn);</span><br><span class="line"></span><br><span class="line">  dout(<span class="number">30</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" transaction dump:\n"</span>;</span><br><span class="line">  <span class="function">JSONFormatter <span class="title">f</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">  t-&gt;dump(&amp;f);</span><br><span class="line">  f.flush(*_dout);</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">debug_tx</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;MonitorDBStore::Transaction&gt;())</span></span>;</span><br><span class="line">  bufferlist::iterator new_value_it = new_value.begin();</span><br><span class="line">  debug_tx-&gt;decode(new_value_it);</span><br><span class="line">  debug_tx-&gt;dump(&amp;f);</span><br><span class="line">  *_dout &lt;&lt; <span class="string">"\nbl dump:\n"</span>;</span><br><span class="line">  f.flush(*_dout);</span><br><span class="line">  *_dout &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  logger-&gt;inc(l_paxos_begin);</span><br><span class="line">  logger-&gt;inc(l_paxos_begin_keys, t-&gt;get_keys());</span><br><span class="line">  logger-&gt;inc(l_paxos_begin_bytes, t-&gt;get_bytes());</span><br><span class="line">  <span class="keyword">utime_t</span> start = ceph_clock_now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将提案持久化存储在DB中</span></span><br><span class="line">  get_store()-&gt;apply_transaction(t);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">utime_t</span> end = ceph_clock_now();</span><br><span class="line">  logger-&gt;tinc(l_paxos_begin_latency, end - start);</span><br><span class="line"></span><br><span class="line">  assert(g_conf-&gt;paxos_kill_at != <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mon-&gt;get_quorum().size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// we're alone, take it easy</span></span><br><span class="line">    <span class="comment">//如果当前quorum中只有一个monitor实例，则提案直接被选定，开始将提案进行commit</span></span><br><span class="line">    commit_start();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask others to accept it too!</span></span><br><span class="line">  <span class="comment">//将天发送至quorum中的所有其他成员（peon），</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::const_iterator p = mon-&gt;get_quorum().begin();</span><br><span class="line">       p != mon-&gt;get_quorum().end();</span><br><span class="line">       ++p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p == mon-&gt;rank) <span class="keyword">continue</span>; <span class="comment">//该成员为实例本身</span></span><br><span class="line">    </span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">" sending begin to mon."</span> &lt;&lt; *p &lt;&lt; dendl;</span><br><span class="line">    MMonPaxos *begin = <span class="keyword">new</span> MMonPaxos(mon-&gt;get_epoch(), MMonPaxos::OP_BEGIN,</span><br><span class="line">				     ceph_clock_now());</span><br><span class="line">    begin-&gt;values[last_committed+<span class="number">1</span>] = new_value;</span><br><span class="line">    begin-&gt;last_committed = last_committed;</span><br><span class="line">    begin-&gt;pn = accepted_pn;</span><br><span class="line">    <span class="comment">//将last_committed及accepted_pn一并发送给peon，供peon判断是否接受本次提案</span></span><br><span class="line">    <span class="comment">//一个leader在任期间内pn都是不会变的</span></span><br><span class="line">    mon-&gt;messenger-&gt;send_message(begin, mon-&gt;monmap-&gt;get_inst(*p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set timeout event</span></span><br><span class="line">  <span class="comment">//设置提案超时的回调</span></span><br><span class="line">  accept_timeout_event = mon-&gt;timer.add_event_after(</span><br><span class="line">    g_conf-&gt;mon_accept_timeout_factor * g_conf-&gt;mon_lease,</span><br><span class="line">    <span class="keyword">new</span> C_MonContext(mon, [<span class="keyword">this</span>](<span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="keyword">if</span> (r == -ECANCELED)</span><br><span class="line">	  <span class="keyword">return</span>;</span><br><span class="line">	accept_timeout();</span><br><span class="line">      &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handle-begin-peon"><a href="#handle-begin-peon" class="headerlink" title="handle_begin(peon)"></a>handle_begin(peon)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peon，处理leader发送过来的begin消息</span></span><br><span class="line"><span class="keyword">void</span> Paxos::handle_begin(MonOpRequestRef op)</span><br><span class="line">&#123;</span><br><span class="line">  op-&gt;mark_paxos_event(<span class="string">"handle_begin"</span>);</span><br><span class="line">  MMonPaxos *begin = <span class="keyword">static_cast</span>&lt;MMonPaxos*&gt;(op-&gt;get_req());</span><br><span class="line">  dout(<span class="number">10</span>) &lt;&lt; <span class="string">"handle_begin "</span> &lt;&lt; *begin &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// can we accept this?</span></span><br><span class="line">  <span class="comment">//如果已经acceptle版本更高的提案，则拒绝此提案，因为一个leader在任期间，pn是不会变的</span></span><br><span class="line">  <span class="comment">//发送此情况多半是leader已经发生了切换</span></span><br><span class="line">  <span class="keyword">if</span> (begin-&gt;pn &lt; accepted_pn) &#123;</span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">" we accepted a higher pn "</span> &lt;&lt; accepted_pn &lt;&lt; <span class="string">", ignoring"</span> &lt;&lt; dendl;</span><br><span class="line">    op-&gt;mark_paxos_event(<span class="string">"have higher pn, ignore"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(begin-&gt;pn == accepted_pn);</span><br><span class="line">  assert(begin-&gt;last_committed == last_committed);</span><br><span class="line">  </span><br><span class="line">  assert(g_conf-&gt;paxos_kill_at != <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  logger-&gt;inc(l_paxos_begin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set state.</span></span><br><span class="line">  <span class="comment">//设置该paxos实例的状态，进入提案决议流程</span></span><br><span class="line">  state = STATE_UPDATING;</span><br><span class="line">  lease_expire = <span class="keyword">utime_t</span>();  <span class="comment">// cancel lease</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接受此次提案</span></span><br><span class="line">  <span class="keyword">version_t</span> v = last_committed+<span class="number">1</span>;</span><br><span class="line">  dout(<span class="number">10</span>) &lt;&lt; <span class="string">"accepting value for "</span> &lt;&lt; v &lt;&lt; <span class="string">" pn "</span> &lt;&lt; accepted_pn &lt;&lt; dendl;</span><br><span class="line">  <span class="comment">// store the accepted value onto our store. We will have to decode it and</span></span><br><span class="line">  <span class="comment">// apply its transaction once we receive permission to commit.</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">t</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;MonitorDBStore::Transaction&gt;())</span></span>;</span><br><span class="line">  t-&gt;put(get_name(), v, begin-&gt;values[v]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// note which pn this pending value is for.</span></span><br><span class="line">  <span class="comment">//更新此次提案的版本号、proposal number等</span></span><br><span class="line">  t-&gt;put(get_name(), <span class="string">"pending_v"</span>, v);</span><br><span class="line">  t-&gt;put(get_name(), <span class="string">"pending_pn"</span>, accepted_pn);</span><br><span class="line"></span><br><span class="line">  dout(<span class="number">30</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" transaction dump:\n"</span>;</span><br><span class="line">  <span class="function">JSONFormatter <span class="title">f</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">  t-&gt;dump(&amp;f);</span><br><span class="line">  f.flush(*_dout);</span><br><span class="line">  *_dout &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  logger-&gt;inc(l_paxos_begin_bytes, t-&gt;get_bytes());</span><br><span class="line">  <span class="keyword">utime_t</span> start = ceph_clock_now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在peon上存储此次提案的值</span></span><br><span class="line">  get_store()-&gt;apply_transaction(t);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">utime_t</span> end = ceph_clock_now();</span><br><span class="line">  logger-&gt;tinc(l_paxos_begin_latency, end - start);</span><br><span class="line"></span><br><span class="line">  assert(g_conf-&gt;paxos_kill_at != <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reply</span></span><br><span class="line">  <span class="comment">//将accept消息回复给leader</span></span><br><span class="line">  MMonPaxos *accept = <span class="keyword">new</span> MMonPaxos(mon-&gt;get_epoch(), MMonPaxos::OP_ACCEPT,</span><br><span class="line">				    ceph_clock_now());</span><br><span class="line">  accept-&gt;pn = accepted_pn;</span><br><span class="line">  accept-&gt;last_committed = last_committed;</span><br><span class="line">  begin-&gt;get_connection()-&gt;send_message(accept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handle-accept-leader"><a href="#handle-accept-leader" class="headerlink" title="handle_accept(leader)"></a>handle_accept(leader)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leader，处理peon发送回来的accept消息</span></span><br><span class="line"><span class="keyword">void</span> Paxos::handle_accept(MonOpRequestRef op)</span><br><span class="line">&#123;</span><br><span class="line">  op-&gt;mark_paxos_event(<span class="string">"handle_accept"</span>);</span><br><span class="line">  MMonPaxos *accept = <span class="keyword">static_cast</span>&lt;MMonPaxos*&gt;(op-&gt;get_req());</span><br><span class="line">  dout(<span class="number">10</span>) &lt;&lt; <span class="string">"handle_accept "</span> &lt;&lt; *accept &lt;&lt; dendl;</span><br><span class="line">  <span class="keyword">int</span> from = accept-&gt;get_source().num();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此消息为前任leader期间的消息，忽略</span></span><br><span class="line">  <span class="keyword">if</span> (accept-&gt;pn != accepted_pn) &#123;</span><br><span class="line">    <span class="comment">// we accepted a higher pn, from some other leader</span></span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">" we accepted a higher pn "</span> &lt;&lt; accepted_pn &lt;&lt; <span class="string">", ignoring"</span> &lt;&lt; dendl;</span><br><span class="line">    op-&gt;mark_paxos_event(<span class="string">"have higher pn, ignore"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//此消息为过时消息，忽略</span></span><br><span class="line">  <span class="keyword">if</span> (last_committed &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      accept-&gt;last_committed &lt; last_committed<span class="number">-1</span>) &#123;</span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">" this is from an old round, ignoring"</span> &lt;&lt; dendl;</span><br><span class="line">    op-&gt;mark_paxos_event(<span class="string">"old round, ignore"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to do ??不明白</span></span><br><span class="line">  assert(accept-&gt;last_committed == last_committed ||   <span class="comment">// not committed</span></span><br><span class="line">	 accept-&gt;last_committed == last_committed<span class="number">-1</span>);  <span class="comment">// committed</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//一次只能由一个提案处以决议中</span></span><br><span class="line">  assert(is_updating() || is_updating_previous());</span><br><span class="line">  assert(accepted.count(from) == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//from这个peon已经同意此提案</span></span><br><span class="line">  accepted.insert(from);</span><br><span class="line">  dout(<span class="number">10</span>) &lt;&lt; <span class="string">" now "</span> &lt;&lt; accepted &lt;&lt; <span class="string">" have accepted"</span> &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  assert(g_conf-&gt;paxos_kill_at != <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// only commit (and expose committed state) when we get *all* quorum</span></span><br><span class="line">  <span class="comment">// members to accept.  otherwise, they may still be sharing the now</span></span><br><span class="line">  <span class="comment">// stale state.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> we can improve this with an additional lease revocation message</span></span><br><span class="line">  <span class="comment">// that doesn't block for the persist.</span></span><br><span class="line">  <span class="comment">//与标准paxos不同的是，Monitor总要quorum的所有成员全部accept一个提案，这个提案才算被选定，</span></span><br><span class="line">  <span class="comment">//这样能简化paoxs的实现，但是在mon节点发生故障时，paxos服务会短暂不可用，直至形成新的quorum</span></span><br><span class="line">  <span class="comment">//由于一次只有一个提案处于决议中，形成新的quorum过程也较快</span></span><br><span class="line">  <span class="comment">//如果提案被选定了，就开始进入commit阶段</span></span><br><span class="line">  <span class="keyword">if</span> (accepted == mon-&gt;get_quorum()) &#123;</span><br><span class="line">    <span class="comment">// yay, commit!</span></span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">" got majority, committing, done with update"</span> &lt;&lt; dendl;</span><br><span class="line">    op-&gt;mark_paxos_event(<span class="string">"commit_start"</span>);</span><br><span class="line">    commit_start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="commit-start-leader"><a href="#commit-start-leader" class="headerlink" title="commit_start(leader)"></a>commit_start(leader)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leader，开始提案commit流程</span></span><br><span class="line"><span class="keyword">void</span> Paxos::commit_start()</span><br><span class="line">&#123;</span><br><span class="line">  dout(<span class="number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" "</span> &lt;&lt; (last_committed+<span class="number">1</span>) &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  assert(g_conf-&gt;paxos_kill_at != <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">t</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;MonitorDBStore::Transaction&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// commit locally</span></span><br><span class="line">  <span class="comment">//更新本地last_commited的值为最新提案的版本号</span></span><br><span class="line">  t-&gt;put(get_name(), <span class="string">"last_committed"</span>, last_committed + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// decode the value and apply its transaction to the store.</span></span><br><span class="line">  <span class="comment">// this value can now be read from last_committed.</span></span><br><span class="line">  decode_append_transaction(t, new_value);</span><br><span class="line"></span><br><span class="line">  dout(<span class="number">30</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" transaction dump:\n"</span>;</span><br><span class="line">  <span class="function">JSONFormatter <span class="title">f</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">  t-&gt;dump(&amp;f);</span><br><span class="line">  f.flush(*_dout);</span><br><span class="line">  *_dout &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  logger-&gt;inc(l_paxos_commit);</span><br><span class="line">  logger-&gt;inc(l_paxos_commit_keys, t-&gt;get_keys());</span><br><span class="line">  logger-&gt;inc(l_paxos_commit_bytes, t-&gt;get_bytes());</span><br><span class="line">  commit_start_stamp = ceph_clock_now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将提案对应的事务在本地DB中生效</span></span><br><span class="line">  <span class="comment">//本地提交后,会调用C_Committed中的回调函数commit_finish</span></span><br><span class="line">  get_store()-&gt;queue_transaction(t, <span class="keyword">new</span> C_Committed(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新leader状态为STATE_WRITING_PREVIOUS或者STATE_WRITING</span></span><br><span class="line">  <span class="keyword">if</span> (is_updating_previous())</span><br><span class="line">    state = STATE_WRITING_PREVIOUS或者;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (is_updating())</span><br><span class="line">    state = STATE_WRITING;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ceph_abort();</span><br><span class="line">  ++commits_started;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mon-&gt;get_quorum().size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// cancel timeout event</span></span><br><span class="line">    mon-&gt;timer.cancel_event(accept_timeout_event);</span><br><span class="line">    accept_timeout_event = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="commit-finish-leader"><a href="#commit-finish-leader" class="headerlink" title="commit_finish(leader)"></a>commit_finish(leader)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leader，将commit操作下发至peon，刷写leader的状态</span></span><br><span class="line"><span class="keyword">void</span> Paxos::commit_finish()</span><br><span class="line">&#123;</span><br><span class="line">  dout(<span class="number">20</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">" "</span> &lt;&lt; (last_committed+<span class="number">1</span>) &lt;&lt; dendl;</span><br><span class="line">  <span class="keyword">utime_t</span> end = ceph_clock_now();</span><br><span class="line">  logger-&gt;tinc(l_paxos_commit_latency, end - commit_start_stamp);</span><br><span class="line"></span><br><span class="line">  assert(g_conf-&gt;paxos_kill_at != <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cancel lease - it was for the old value.</span></span><br><span class="line">  <span class="comment">//  (this would only happen if message layer lost the 'begin', but</span></span><br><span class="line">  <span class="comment">//   leader still got a majority and committed with out us.)</span></span><br><span class="line">  lease_expire = <span class="keyword">utime_t</span>();  <span class="comment">// cancel lease</span></span><br><span class="line"></span><br><span class="line">  last_committed++;</span><br><span class="line">  last_commit_time = ceph_clock_now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// refresh first_committed; this txn may have trimmed.</span></span><br><span class="line">  first_committed = get_store()-&gt;get(get_name(), <span class="string">"first_committed"</span>);</span><br><span class="line"></span><br><span class="line">  _sanity_check_store();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell everyone</span></span><br><span class="line">  <span class="comment">//给quorum中的所有peon发送commit信息</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::const_iterator p = mon-&gt;get_quorum().begin();</span><br><span class="line">       p != mon-&gt;get_quorum().end();</span><br><span class="line">       ++p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p == mon-&gt;rank) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">" sending commit to mon."</span> &lt;&lt; *p &lt;&lt; dendl;</span><br><span class="line">    MMonPaxos *commit = <span class="keyword">new</span> MMonPaxos(mon-&gt;get_epoch(), MMonPaxos::OP_COMMIT,</span><br><span class="line">				      ceph_clock_now());</span><br><span class="line">    commit-&gt;values[last_committed] = new_value;</span><br><span class="line">    commit-&gt;pn = accepted_pn;</span><br><span class="line">    commit-&gt;last_committed = last_committed;</span><br><span class="line"></span><br><span class="line">    mon-&gt;messenger-&gt;send_message(commit, mon-&gt;monmap-&gt;get_inst(*p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(g_conf-&gt;paxos_kill_at != <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get ready for a new round.</span></span><br><span class="line">  new_value.clear();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// WRITING -&gt; REFRESH</span></span><br><span class="line">  <span class="comment">// among other things, this lets do_refresh() -&gt; mon-&gt;bootstrap() know</span></span><br><span class="line">  <span class="comment">// it doesn't need to flush the store queue</span></span><br><span class="line">  <span class="comment">//更新状态为STATE_REFRESH</span></span><br><span class="line">  assert(is_writing() || is_writing_previous());</span><br><span class="line">  state = STATE_REFRESH;</span><br><span class="line">  assert(commits_started &gt; <span class="number">0</span>);</span><br><span class="line">  --commits_started;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//其中，do_refresh是让上层服务刷新状态，获取最新的commit信息等</span></span><br><span class="line">  <span class="keyword">if</span> (do_refresh()) &#123;</span><br><span class="line">    commit_proposal();</span><br><span class="line">    <span class="keyword">if</span> (mon-&gt;get_quorum().size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      extend_lease();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finish_contexts(g_ceph_context, waiting_for_commit);</span><br><span class="line"></span><br><span class="line">    assert(g_conf-&gt;paxos_kill_at != <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    finish_round();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handle-commit-peon"><a href="#handle-commit-peon" class="headerlink" title="handle_commit(peon)"></a>handle_commit(peon)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//peon，处理leader发送过来的commit消息</span></span><br><span class="line"><span class="keyword">void</span> Paxos::handle_commit(MonOpRequestRef op)</span><br><span class="line">&#123;</span><br><span class="line">  op-&gt;mark_paxos_event(<span class="string">"handle_commit"</span>);</span><br><span class="line">  MMonPaxos *commit = <span class="keyword">static_cast</span>&lt;MMonPaxos*&gt;(op-&gt;get_req());</span><br><span class="line">  dout(<span class="number">10</span>) &lt;&lt; <span class="string">"handle_commit on "</span> &lt;&lt; commit-&gt;last_committed &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  logger-&gt;inc(l_paxos_commit);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!mon-&gt;is_peon()) &#123;</span><br><span class="line">    dout(<span class="number">10</span>) &lt;&lt; <span class="string">"not a peon, dropping"</span> &lt;&lt; dendl;</span><br><span class="line">    ceph_abort();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//to do?? 不知道啊</span></span><br><span class="line">  op-&gt;mark_paxos_event(<span class="string">"store_state"</span>);</span><br><span class="line">  store_state(commit);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (do_refresh()) &#123;</span><br><span class="line">  	<span class="comment">//唤醒等待中的回调函数</span></span><br><span class="line">    finish_contexts(g_ceph_context, waiting_for_commit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，一轮提案决议过程就算完成了，monitor会发送ack信息给客户端,各个paxos实例便算完成了数据恢复和同步，leader的状态转换图如下所示：</p>
<p><img src="/images/13.png" alt=""></p>
<p>对应的转换操作如下:</p>
<ul>
<li>active-updating：接收到提案请求，将提案持久化存储，进入提案状态</li>
<li>updating-writing：quorum的全部成员都同意此提案，开始提交提案</li>
<li>writing-refresh：leader commit成功，并通知其他节点提交，开始刷新上层服务，通知上层可读</li>
<li>refresh-active：刷新完成，一轮提案完成</li>
</ul>
<p>peon的状态转换图如下所示：</p>
<p><img src="/images/14.png" alt=""></p>
<p>peon在接收到提案后就进入updating状态，此状态期间是不提供读服务的，提案完成后接收到leader的lease后会重新进入active状态</p>
<h2 id="异常恢复"><a href="#异常恢复" class="headerlink" title="异常恢复"></a>异常恢复</h2><p>下面分别以leader异常退出和peon异常退出为例来看数据是如何恢复的。<br>在看具体恢复例子时，要先清除整个paxos实例的一个状态转换图，清楚在每个状态异常退出时，数据是如何来恢复的，如下：</p>
<p><img src="/images/15.png" alt=""></p>
<p>leader节点在选举成功之后会进入recovering状态用以尝试恢复数据，如果发现有未提交的数据，则会进入updating_previous状态，开始恢复数据，下面通过两种情况来分析monitor中paxos的恢复逻辑。</p>
<h3 id="Peon-down"><a href="#Peon-down" class="headerlink" title="Peon down"></a>Peon down</h3><p>peon节点down掉之后会触发选主流程，由于monitor是根据ip来选主的，原先的leader节点必定还会当选，且它的数据一定是最新的，leader节点只需进入数据恢复流程，尝试提交尚未commit的数据即可。</p>
<p>down的节点在之后加入集群后通过probing阶段便可同步数据，之后正常加入集群，leader节点不会变化</p>
<h3 id="Leader-down"><a href="#Leader-down" class="headerlink" title="Leader down"></a>Leader down</h3><p>leader节点可能down在任意状态，下面分别从leader down、leader up后集群如何恢复正常来看整个数据恢复流程。</p>
<h4 id="down"><a href="#down" class="headerlink" title="down"></a>down</h4><p>leader down了之后，有新的peon节点当选为leader，leader节点可能down在以下几种状态：</p>
<ul>
<li>down在active状态，无需恢复数据</li>
<li>down在updating状态，如果没有peon accept提案，则无需恢复数据。如果有的话，peon只需学习该提案即可</li>
<li>down在writing状态，说明所有peon已经accept提案，新的leader会从新propose该提案</li>
<li>down在refresh状态，说明老的leader已经成功提交提案，如果peon已经收到commit消息，则该提案会被学习到，若未收到的话，会重新propose该提案</li>
</ul>
<h4 id="up"><a href="#up" class="headerlink" title="up"></a>up</h4><p>leader节点在重新up后，会通过probing阶段做数据同步，当选为leader之后会进入数据恢复流程。</p>
<p>节点异常恢复分析需要重点关注下是否会存在数据丢失或者不一致的情况，peon节点down掉肯定不会造成数据丢失和不一致。唯一需要注意的是leader点down掉，如果数据已经commit了的话，peon处肯定是会持久存储的，所以不会有数据丢失，如果还有uncommited的数据的话，如果有peon已经接收的话，是会被重新学习的，所以不会造成数据丢失和不一致。</p>
<h2 id="一致性达成"><a href="#一致性达成" class="headerlink" title="一致性达成"></a>一致性达成</h2><p>要保证强一致性的读取，有以下两个点需要注意：</p>
<ul>
<li>如果防止读到过期的数据</li>
<li>如何防止读到尚未commit的数据</li>
</ul>
<p>ceph-monitor中是通过租约机制来保证读的，持有lease的节点才能被读取数据，在提案过程之中所有节点的租约是会回收的，即提案过程中，paxos层是不可读的，这对于monitor这种典型的读多写少的场景也是一种合理的取舍。<br>同时通过以上的分析可知，每个提案是有一个版本号的，上层应用层在读取数据的时候需要带上版本号来读取数据，对于尚未commit的提案，是不可能会被读取到的，反应在应用层就是读请求会阻塞住，直至该提案可读。</p>
<h2 id="定制化实现"><a href="#定制化实现" class="headerlink" title="定制化实现"></a>定制化实现</h2><p>与标准的multi-paxos或者其他paxos工程化实现，ceph-monitor中的paxos做了如下实现：</p>
<ul>
<li><p>quorum：与其他共识算法实现很不同的是，ceph-paxos中quorum成员在选主之后就是固定的，之后所有的决议都要全部quorum成员的同意，任何一个quorum成员的变化都会触发重新选主。这样能简化paxos的实现，但是如果quorum成员变化频繁的话，ceph-paxos的可用性和性能就会受到很大影响。考虑到Monitor的节点数较少，这种取舍也是合理的</p>
</li>
<li><p>一次决议一个值：ceph-paxos一次只能决议一个值，同时对于决议值要求所有的quorum成员都应答，即不允许参与决议的节点存在日志空洞，前一条日志commit之后才能发起下个提案，这样能非常有效简化数据恢复流程。对于决议过程中的新提案请求，ceph-paxos层及上层的应用层都会进行聚合，这样能有效降低monitor的写入压力</p>
</li>
<li><p>读取：leader节点会给peon节点发放lease，持有lease的节点可以接收读请求，如果有提案在决议过程中，则取消peon的lease，防止读到旧的数据，提案commit之后peon节点会重新获得lease。通过每个提案会有个版本号，应用层读取数据时会带上此版本号用以读取最新的数据，通过这样的机制可以保证强一致性读，lease的引入对于monitor这种典型的读多写少的应用也是非常有效的</p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://catkang.github.io/2016/07/17/ceph-monitor-and-paxos.html" target="_blank" rel="noopener">Ceph Monitor and Paxos</a></li>
<li><a href="http://bean-li.github.io/ceph-paxos/" target="_blank" rel="noopener">ceph-mon之Paxos算法</a></li>
<li><a href="http://blog.wjin.org/posts/ceph-monitor-paxos.html" target="_blank" rel="noopener">Ceph Monitor Paxos</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/cpp-string3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/08/cpp-string3/" itemprop="url">漫谈C++ string（3）：FBString的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-08T15:11:10+08:00">
                2019-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>FBString</code>是<code>folly</code>中关于<code>std::string</code>的实现，它更加精细地控制了内存的使用，在64位X86平台上，它的实现方式如下：</p>
<ul>
<li>对于小字符串（0~23字节），直接将数据存储在栈内，不需在对上开辟空间，因为栈的访问效率较高</li>
<li>中等长度的字符串（24~254字节），在堆上开辟空间，发生拷贝时直接复制整个字符串</li>
<li>大长度的字符串（大于254字节），在堆上开辟空间，采用COW机制</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>fbstring</code>的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_fbstring&lt;<span class="keyword">char</span>&gt; fbstring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">A</span>, <span class="title">class</span> <span class="title">Storage</span>&gt;</span></span><br><span class="line"><span class="class">#<span class="title">else</span></span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;</span></span><br><span class="line"><span class="class">    typename E,</span></span><br><span class="line"><span class="class">    class T = std::char_traits&lt;E&gt;,</span></span><br><span class="line"><span class="class">    class A = std::allocator&lt;E&gt;,</span></span><br><span class="line"><span class="class">    class Storage = fbstring_core&lt;E&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">basic_fbstring</span> &#123;</span>&#125;</span><br><span class="line"><span class="function">class <span class="title">fbstring_core</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MediumLarge</span> &#123;</span></span><br><span class="line">    Char* data_;</span><br><span class="line">    <span class="keyword">size_t</span> size_;</span><br><span class="line">    <span class="keyword">size_t</span> capacity_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> capacity() <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> kIsLittleEndian ? capacity_ &amp; capacityExtractMask : capacity_ &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCapacity</span><span class="params">(<span class="keyword">size_t</span> cap, Category cat)</span> </span>&#123;</span><br><span class="line">      capacity_ = kIsLittleEndian</span><br><span class="line">          ? cap | (<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(cat) &lt;&lt; kCategoryShift)</span><br><span class="line">          : (cap &lt;&lt; <span class="number">2</span>) | <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(cat);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将短字符串存储在栈区，用union存储，可以有效节省内存</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> bytes_[<span class="keyword">sizeof</span>(MediumLarge)]; <span class="comment">// 存储所有字节</span></span><br><span class="line">    Char small_[<span class="keyword">sizeof</span>(MediumLarge) / <span class="keyword">sizeof</span>(Char)];</span><br><span class="line">    MediumLarge ml_;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">size_t</span> lastChar = <span class="keyword">sizeof</span>(MediumLarge) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">size_t</span> maxSmallSize = lastChar / <span class="keyword">sizeof</span>(Char);<span class="comment">//64为x86平台为23个（宽）字节</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">size_t</span> maxMediumSize = <span class="number">254</span> / <span class="keyword">sizeof</span>(Char);</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">uint8_t</span> categoryExtractMask = kIsLittleEndian ? <span class="number">0xC0</span> : <span class="number">0x3</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">size_t</span> kCategoryShift = (<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">size_t</span> capacityExtractMask = kIsLittleEndian</span><br><span class="line">      ? ~(<span class="keyword">size_t</span>(categoryExtractMask) &lt;&lt; kCategoryShift)</span><br><span class="line">      : <span class="number">0x0</span> <span class="comment">/* unused */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看<code>fbstring_core</code>的实现。</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>还是以最常见的std::string(“xxx”)这种构造方式为例来看它对应的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fbstring_core(</span><br><span class="line">    <span class="keyword">const</span> Char* <span class="keyword">const</span> data,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> size,</span><br><span class="line">    <span class="keyword">bool</span> disableSSO = FBSTRING_DISABLE_SSO) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!disableSSO &amp;&amp; size &lt;= maxSmallSize) &#123;</span><br><span class="line">    <span class="comment">//SSO（Small String Optiomition），即短字符串优化</span></span><br><span class="line">    initSmall(data, size);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= maxMediumSize) &#123;</span><br><span class="line">    initMedium(data, size);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    initLarge(data, size);</span><br><span class="line">  &#125;</span><br><span class="line">  FBSTRING_ASSERT(<span class="keyword">this</span>-&gt;size() == size);</span><br><span class="line">  FBSTRING_ASSERT(</span><br><span class="line">      size == <span class="number">0</span> || <span class="built_in">memcmp</span>(<span class="keyword">this</span>-&gt;data(), data, size * <span class="keyword">sizeof</span>(Char)) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如前文所述，对不不同的size，它的实现方式是不一样的，下面来逐个分析。</p>
<ul>
<li>Small</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Char</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">fbstring_core</span>&lt;Char&gt;:</span>:initSmall(</span><br><span class="line">    <span class="keyword">const</span> Char* <span class="keyword">const</span> data,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">  <span class="comment">// Layout is: Char* data_, size_t size_, size_t capacity_</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">//如果数据是内存对齐的，则用字长快速复制，否则的话就用保守的memcpy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FBSTRING_SANITIZE_ADDRESS</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">size_t</span>&gt;(data) &amp; (<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> byteSize = size * <span class="keyword">sizeof</span>(Char);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">size_t</span> wordWidth = <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">switch</span> ((byteSize + wordWidth - <span class="number">1</span>) / wordWidth) &#123; <span class="comment">// Number of words.</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ml_.capacity_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(data)[<span class="number">2</span>];</span><br><span class="line">        FOLLY_FALLTHROUGH;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ml_.size_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(data)[<span class="number">1</span>];</span><br><span class="line">        FOLLY_FALLTHROUGH;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ml_.data_ = *<span class="keyword">reinterpret_cast</span>&lt;Char**&gt;(<span class="keyword">const_cast</span>&lt;Char*&gt;(data));</span><br><span class="line">        FOLLY_FALLTHROUGH;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//调用memcpy将data复制至small_</span></span><br><span class="line">      fbstring_detail::podCopy(data, data + size, small_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setSmallSize(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setSmallSize</span><span class="params">(<span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Warning: this should work with uninitialized strings too,</span></span><br><span class="line">    <span class="comment">// so don't assume anything about the previous value of</span></span><br><span class="line">    <span class="comment">// small_[maxSmallSize].</span></span><br><span class="line">    <span class="comment">//string未经初始化时也要能调用，此时small_中可能没有数据</span></span><br><span class="line">    FBSTRING_ASSERT(s &lt;= maxSmallSize);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> shift = kIsLittleEndian ? <span class="number">0</span> : <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//用small_中的最后一个字节来存储字符串大小的信息</span></span><br><span class="line">    small_[maxSmallSize] = <span class="keyword">char</span>((maxSmallSize - s) &lt;&lt; shift);</span><br><span class="line">    small_[s] = <span class="string">'\0'</span>;</span><br><span class="line">    FBSTRING_ASSERT(category() == Category::isSmall &amp;&amp; size() == s);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，短字符串的内存结构如下所示：</p>
<p><img src="/images/cpp/fbstring_small.png" alt=""></p>
<p>由于需要一个字节存储size，另外需要一个字节存储结束符，所以small_中最多能存22个字节。</p>
<p>另外还有个问题就是字符串的类型（small、medium、large）是存储在哪的？答案就是同上图的size存在一起，即存在<code>bytes_</code>的最后一个字节中，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为前面也说到，短字符串的长度最多只有22个字节，存储这个长度不需要占用整个字节，所以可以用最后一个字节的高两位来存储字符串的类型，由此可见FBString对内存控制的精细度。</p>
<ul>
<li>Medium</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Char</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FOLLY_MALLOC_NOINLINE</span> <span class="title">inline</span> <span class="title">void</span> <span class="title">fbstring_core</span>&lt;Char&gt;:</span>:initMedium(</span><br><span class="line">    <span class="keyword">const</span> Char* <span class="keyword">const</span> data,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">  <span class="comment">// 多分配一个字符用以存储结束符，将data指向分配的首地址</span></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> allocSize = goodMallocSize((<span class="number">1</span> + size) * <span class="keyword">sizeof</span>(Char));</span><br><span class="line">  ml_.data_ = <span class="keyword">static_cast</span>&lt;Char*&gt;(checkedMalloc(allocSize));</span><br><span class="line">  <span class="comment">//调用memcpy</span></span><br><span class="line">  <span class="keyword">if</span> (FBSTRING_LIKELY(size &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    fbstring_detail::podCopy(data, data + size, ml_.data_);</span><br><span class="line">  &#125;</span><br><span class="line">  ml_.size_ = size;</span><br><span class="line">  <span class="comment">//设置容量及存储类别</span></span><br><span class="line">  ml_.setCapacity(allocSize / <span class="keyword">sizeof</span>(Char) - <span class="number">1</span>, Category::isMedium);</span><br><span class="line">  ml_.data_[size] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，中型字符串的内存结构如下所示：</p>
<p><img src="/images/cpp/fbstring_medium.png" alt=""></p>
<ul>
<li>Large</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Char</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FOLLY_MALLOC_NOINLINE</span> <span class="title">inline</span> <span class="title">void</span> <span class="title">fbstring_core</span>&lt;Char&gt;:</span>:initLarge(</span><br><span class="line">    <span class="keyword">const</span> Char* <span class="keyword">const</span> data,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">  <span class="comment">// 大字符串启用COW</span></span><br><span class="line">  <span class="keyword">size_t</span> effectiveCapacity = size;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> newRC = RefCounted::create(data, &amp;effectiveCapacity);</span><br><span class="line">  ml_.data_ = newRC-&gt;data_;</span><br><span class="line">  ml_.size_ = size;</span><br><span class="line">  ml_.setCapacity(effectiveCapacity, Category::isLarge);</span><br><span class="line">  ml_.data_[size] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RefCounted</span> &#123;</span></span><br><span class="line">    <span class="comment">//使用atomic存储引用计数，data存在随后的连续内存中，提高内存使用效率</span></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; refCount_;</span><br><span class="line">    Char data_[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> RefCounted* <span class="title">create</span><span class="params">(<span class="keyword">size_t</span>* size)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//通过goodMallocSize将size对齐，提高内存分配效率</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">size_t</span> allocSize =</span><br><span class="line">          goodMallocSize(getDataOffset() + (*size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(Char));</span><br><span class="line">      <span class="keyword">auto</span> result = <span class="keyword">static_cast</span>&lt;RefCounted*&gt;(checkedMalloc(allocSize));</span><br><span class="line">      result-&gt;refCount_.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">      *size = (allocSize - getDataOffset()) / <span class="keyword">sizeof</span>(Char) - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RefCounted* <span class="title">create</span><span class="params">(<span class="keyword">const</span> Char* data, <span class="keyword">size_t</span>* size)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">size_t</span> effectiveSize = *size;</span><br><span class="line">      <span class="keyword">auto</span> result = create(size);</span><br><span class="line">      <span class="keyword">if</span> (FBSTRING_LIKELY(effectiveSize &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//调用memcpy</span></span><br><span class="line">        fbstring_detail::podCopy(data, data + effectiveSize, result-&gt;data_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>大型字符串的内存分布同中型字符串基本相同，仅仅多了个引用计数需要存储，如下所示：</p>
<p><img src="/images/cpp/fbstring_large.png" alt=""></p>
<p>到此，还有个问题就是字符串的类别是如何存储的，代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span> category_type;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> :</span> category_type &#123;</span><br><span class="line">  isSmall = <span class="number">0</span>,</span><br><span class="line">  isMedium = kIsLittleEndian ? <span class="number">0x80</span> : <span class="number">0x2</span>,</span><br><span class="line">  isLarge = kIsLittleEndian ? <span class="number">0x40</span> : <span class="number">0x1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//categoryExtractMask = kIsLittleEndian ? 0xC0 : 0x3;</span></span><br><span class="line"><span class="function">Category <span class="title">category</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// works for both big-endian and little-endian</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Category&gt;(bytes_[lastChar] &amp; categoryExtractMask);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MediumLarge</span> &#123;</span></span><br><span class="line">    Char* data_;</span><br><span class="line">    <span class="keyword">size_t</span> size_;</span><br><span class="line">    <span class="keyword">size_t</span> capacity_;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 小端序情况下，capacityExtractMask = ~(size_t(categoryExtractMask) &lt;&lt; kCategoryShift)</span></span><br><span class="line">    <span class="keyword">size_t</span> capacity() <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> kIsLittleEndian ? capacity_ &amp; capacityExtractMask : capacity_ &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// kCategoryShift = (sizeof(size_t) - 1) * 8;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCapacity</span><span class="params">(<span class="keyword">size_t</span> cap, Category cat)</span> </span>&#123;</span><br><span class="line">      capacity_ = kIsLittleEndian</span><br><span class="line">          ? cap | (<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(cat) &lt;&lt; kCategoryShift)</span><br><span class="line">          : (cap &lt;&lt; <span class="number">2</span>) | <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(cat);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>由此可见，basic_string栈中最后一个字节的高两位被用来存储字符串类型，在短字符串中，该字节存储的是字符串的size，由于此时size最多为22，所以高两位是不需要的，所以可以用来存类别，而在中大型字符串中，这两位对应于capacity中的最高两位，现有主机的内存没有这么大，所以这高两位也不可能用到，因此可以用来存储字符串类型。由此可见，FBString对内存的利用控制得多精细。</p>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>看完了构造函数，下面来看拷贝构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fbstring_core(<span class="keyword">const</span> fbstring_core&amp; rhs) &#123;</span><br><span class="line">  FBSTRING_ASSERT(&amp;rhs != <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">switch</span> (rhs.category()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Category::isSmall:</span><br><span class="line">      copySmall(rhs);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Category::isMedium:</span><br><span class="line">      copyMedium(rhs);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Category::isLarge:</span><br><span class="line">      copyLarge(rhs);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      folly::assume_unreachable();</span><br><span class="line">  &#125;</span><br><span class="line">  FBSTRING_ASSERT(size() == rhs.size());</span><br><span class="line">  FBSTRING_ASSERT(<span class="built_in">memcmp</span>(data(), rhs.data(), size() * <span class="keyword">sizeof</span>(Char)) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来分别看不同尺寸下的拷贝构造函数是如何实现的。</p>
<ul>
<li>Small</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Char</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">fbstring_core</span>&lt;Char&gt;:</span>:copySmall(<span class="keyword">const</span> fbstring_core&amp; rhs) &#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(offsetof(MediumLarge, data_) == <span class="number">0</span>, <span class="string">"fbstring layout failure"</span>);</span><br><span class="line">  <span class="keyword">static_assert</span>(</span><br><span class="line">      offsetof(MediumLarge, size_) == <span class="keyword">sizeof</span>(ml_.data_),</span><br><span class="line">      <span class="string">"fbstring layout failure"</span>);</span><br><span class="line">  <span class="keyword">static_assert</span>(</span><br><span class="line">      offsetof(MediumLarge, capacity_) == <span class="number">2</span> * <span class="keyword">sizeof</span>(ml_.data_),</span><br><span class="line">      <span class="string">"fbstring layout failure"</span>);</span><br><span class="line">  <span class="comment">// Just write the whole thing, don't look at details. In</span></span><br><span class="line">  <span class="comment">// particular we need to copy capacity anyway because we want</span></span><br><span class="line">  <span class="comment">// to set the size (don't forget that the last character,</span></span><br><span class="line">  <span class="comment">// which stores a short string's length, is shared with the</span></span><br><span class="line">  <span class="comment">// ml_.capacity field).</span></span><br><span class="line">  ml_ = rhs.ml_;</span><br><span class="line">  FBSTRING_ASSERT(</span><br><span class="line">      category() == Category::isSmall &amp;&amp; <span class="keyword">this</span>-&gt;size() == rhs.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Medium</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Char</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FOLLY_MALLOC_NOINLINE</span> <span class="title">inline</span> <span class="title">void</span> <span class="title">fbstring_core</span>&lt;Char&gt;:</span>:copyMedium(</span><br><span class="line">    <span class="keyword">const</span> fbstring_core&amp; rhs) &#123;</span><br><span class="line">  <span class="comment">//中型字符串总是采用eager-copy的方式，即字符串的拷贝总会重新分配内存并拷贝内容</span></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> allocSize = goodMallocSize((<span class="number">1</span> + rhs.ml_.size_) * <span class="keyword">sizeof</span>(Char));</span><br><span class="line">  ml_.data_ = <span class="keyword">static_cast</span>&lt;Char*&gt;(checkedMalloc(allocSize));</span><br><span class="line">  fbstring_detail::podCopy(</span><br><span class="line">      rhs.ml_.data_, rhs.ml_.data_ + rhs.ml_.size_ + <span class="number">1</span>, ml_.data_);</span><br><span class="line">  ml_.size_ = rhs.ml_.size_;</span><br><span class="line">  ml_.setCapacity(allocSize / <span class="keyword">sizeof</span>(Char) - <span class="number">1</span>, Category::isMedium);</span><br><span class="line">  FBSTRING_ASSERT(category() == Category::isMedium);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Large</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Char</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FOLLY_MALLOC_NOINLINE</span> <span class="title">inline</span> <span class="title">void</span> <span class="title">fbstring_core</span>&lt;Char&gt;:</span>:copyLarge(</span><br><span class="line">    <span class="keyword">const</span> fbstring_core&amp; rhs) &#123;</span><br><span class="line">  <span class="comment">//大型字符串采用COW</span></span><br><span class="line">  ml_ = rhs.ml_;</span><br><span class="line">  RefCounted::incrementRefs(ml_.data_);</span><br><span class="line">  FBSTRING_ASSERT(category() == Category::isLarge &amp;&amp; size() == rhs.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看字符串的修改是如何实现的，显而易见的是，Large的修改会导致内存的重新分配，Small及Medium字符串由于是采用的<code>eager-copy</code>的方式，修改的时候直接返回对应的内存地址即可，以basic_string为例来看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//basic_string</span></span><br><span class="line">reference <span class="keyword">operator</span>[](size_type pos) &#123;</span><br><span class="line">  <span class="keyword">return</span> *(begin() + pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//此处store即是fbstring_core</span></span><br><span class="line">  <span class="keyword">return</span> store_.mutableData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fbstring_core</span></span><br><span class="line"><span class="function">Char* <span class="title">mutableData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (category()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Category::isSmall:</span><br><span class="line">      <span class="keyword">return</span> small_;</span><br><span class="line">    <span class="keyword">case</span> Category::isMedium:</span><br><span class="line">      <span class="keyword">return</span> ml_.data_;</span><br><span class="line">    <span class="keyword">case</span> Category::isLarge:</span><br><span class="line">      <span class="keyword">return</span> mutableDataLarge();</span><br><span class="line">  &#125;</span><br><span class="line">  folly::assume_unreachable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Char</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Char</span>* <span class="title">fbstring_core</span>&lt;Char&gt;:</span>:mutableDataLarge() &#123;</span><br><span class="line">  FBSTRING_ASSERT(category() == Category::isLarge);</span><br><span class="line">  <span class="keyword">if</span> (RefCounted::refs(ml_.data_) &gt; <span class="number">1</span>) &#123; <span class="comment">//如果无其他字符串引用，则直接返回即可，否则需要重新分配内存</span></span><br><span class="line">    unshare();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ml_.data_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Char</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FOLLY_MALLOC_NOINLINE</span> <span class="title">inline</span> <span class="title">void</span> <span class="title">fbstring_core</span>&lt;Char&gt;:</span>:unshare(</span><br><span class="line">    <span class="keyword">size_t</span> minCapacity) &#123;</span><br><span class="line">  FBSTRING_ASSERT(category() == Category::isLarge);</span><br><span class="line">  <span class="keyword">size_t</span> effectiveCapacity = <span class="built_in">std</span>::max(minCapacity, ml_.capacity());</span><br><span class="line">  <span class="comment">//重新分配内存</span></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> newRC = RefCounted::create(&amp;effectiveCapacity);</span><br><span class="line">  FBSTRING_ASSERT(effectiveCapacity &gt;= ml_.capacity());</span><br><span class="line">  <span class="comment">//拷贝数据</span></span><br><span class="line">  fbstring_detail::podCopy(ml_.data_, ml_.data_ + ml_.size_ + <span class="number">1</span>, newRC-&gt;data_);</span><br><span class="line">  RefCounted::decrementRefs(ml_.data_);</span><br><span class="line">  ml_.data_ = newRC-&gt;data_;</span><br><span class="line">  ml_.setCapacity(effectiveCapacity, Category::isLarge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>fbstring在std::string的基础上对于不同尺寸的string采用了不同类型的实现方式，对内存的使用控制非常精细。</li>
<li>短字符串直接存储在栈中从而避免内存分配</li>
<li>中型字符串采用了<code>eager copy</code>的实现方式，因为folly鼓励使用jemalloc来替代glibc下默认的ptmalloc，内存使用使用很高效，开辟这样尺寸的内存可以认为是非常高效的</li>
<li>长字符串则采用了COW的实现，减少内存拷贝</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.cnblogs.com/promise6522/archive/2012/06/05/2535530.html" target="_blank" rel="noopener">漫步Facebook开源C++库folly(1)：string类的设计</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/cpp-string2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/08/cpp-string2/" itemprop="url">漫谈C++ string（2）：string_ref的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-08T15:08:10+08:00">
                2019-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在c++的函数调用中传递字符串引用时非常常见的，但是通常被调函数通常不关心所传参数的实际实际类型，从而可能会发生以下状况：</p>
<ul>
<li>被调函数以<code>std::string(包括std::string&amp;)</code>作为参数，如果调用者传入的是非<code>std::string</code>的数据类型的话，必然会发生数据拷贝</li>
<li>被调函数以<code>char*</code>及<code>length</code>作为参数，则会降低代码可读性和安全性，同时还无法使用标准库提供的一些函数</li>
<li>被调函数是以模板实现的用以支持各种参数，但这通常会增加代码的复杂度和编译时间</li>
<li>被调函数之间需要传递字符串的一部分（substr）时，也必然会发生数据拷贝</li>
</ul>
<p>来看一个具体的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">extract_part</span> <span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;bar )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bar.substr ( <span class="number">2</span>, <span class="number">3</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( extract_part ( <span class="string">"ABCDEFG"</span> ).front() == <span class="string">'C'</span> ) &#123; <span class="comment">/* do something */</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述例子中，一个临时的string变量会被创建出来，然后通过引用传递的方式传入<code>extract_part</code>中，然后第二个临时string变量在调用<code>substr</code>之后会被创建出来，然后返回给调用者的时候也可能会产生数据拷贝（通过<code>RVO</code>可消除）。其实这两个临时变量不是必须要产生的，这说明在以<code>string</code>做为参数传递时经常容易产生不必要的拷贝，特别是对于大字符串来说，避免数据拷贝是很有必要的，但是标准库的<code>COW</code>实现也有问题，参见<a href="https://www.cnblogs.com/promise6522/archive/2012/03/22/2412686.html" target="_blank" rel="noopener">std::string的Copy-on-Write：不如想象中美好</a>,所以很多大型项目或基础库都提供了<code>StringReference</code>的实现，如<code>Boost::StringRef</code>,<code>LLVM的StringRef</code>, <code>Chromium的base::StringPiece</code>等，在c++17中也新增了<code>std::string_view</code>来支持字符串引用。</p>
<h2 id="Chrome-StringPiece"><a href="#Chrome-StringPiece" class="headerlink" title="Chrome StringPiece"></a>Chrome StringPiece</h2><p>Chrome中的StringPiece实现在<code>string/string_piece.h</code>中，它可以作为函数参数和返回值使用，一个StringPiece参数也可以接受std::string、const char*、常量字符串作为输入，这些输入都不会产生数据拷贝。<br><code>StringPiece</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strings/string_piece_forward.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicStringPiece</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> BasicStringPiece&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; StringPiece;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>StringPiece</code>是BasicStringPiece关于std::string的实现，下面来看BasicStringPiece的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">BasicStringPiece</span><span class="params">(<span class="keyword">const</span> value_type* str)</span></span></span><br><span class="line">    : ptr_(str), length_(!str ? 0 : CharTraits&lt;value_type&gt;::length(str)) &#123;&#125;</span><br><span class="line">BasicStringPiece(<span class="keyword">const</span> STRING_TYPE&amp; str)</span><br><span class="line">    : ptr_(str.data()), length_(str.size()) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">BasicStringPiece</span><span class="params">(<span class="keyword">const</span> value_type* offset, size_type len)</span></span></span><br><span class="line">    : ptr_(offset), length_(len) &#123;&#125;</span><br><span class="line">BasicStringPiece(<span class="keyword">const</span> <span class="keyword">typename</span> STRING_TYPE::const_iterator&amp; begin,</span><br><span class="line">                 <span class="keyword">const</span> <span class="keyword">typename</span> STRING_TYPE::const_iterator&amp; end) &#123;&#125;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="keyword">const</span> value_type* ptr_;</span><br><span class="line">size_type length_;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它有两个成员变量，分别是指向的数据以及数据的长度，所以它的传递和拷贝值需要拷贝相应的指针，而不需要拷贝指向的数据，这种实现方式也要求调用者要确保指向数据的有效性。如前文所说，它可以接收<code>const char*</code>、<code>const std::string&amp;</code>作为参数。<br>下面来看它的部分成员函数实现，首先是<code>substr</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// substr.</span></span><br><span class="line">  <span class="function">BasicStringPiece <span class="title">substr</span><span class="params">(size_type pos,</span></span></span><br><span class="line"><span class="function"><span class="params">                          size_type n = BasicStringPiece::npos)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> internal::substr(*<span class="keyword">this</span>, pos, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最终调用函数</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span><br><span class="line">BasicStringPiece&lt;STR&gt; substrT(<span class="keyword">const</span> BasicStringPiece&lt;STR&gt;&amp; self,</span><br><span class="line">                              <span class="keyword">size_t</span> pos,</span><br><span class="line">                              <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt; self.size()) pos = self.size();</span><br><span class="line">  <span class="keyword">if</span> (n &gt; self.size() - pos) n = self.size() - pos;</span><br><span class="line">  <span class="keyword">return</span> BasicStringPiece&lt;STR&gt;(self.data() + pos, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BasicStringPiece::substr最终调用的是substrT这个函数，可以看到的是，它不会产生额外的数据拷贝，只会拷贝指向数据的指针。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://izualzhy.cn/string-piece-introduction" target="_blank" rel="noopener">StringPiece介绍</a></li>
<li><a href="https://www.boost.org/doc/libs/1_61_0/libs/utility/doc/html/string_ref.html#string_ref.examples" target="_blank" rel="noopener">boost:StringRef</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/cpp-string1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/08/cpp-string1/" itemprop="url">漫谈C++ string（1）：std::string实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-08T15:00:39+08:00">
                2019-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从实际使用上来说，std::string跟应该叫做std::string_buffer，因为它的特性更像std::vector而不是std::array，在很多情况下都容易引起数据拷贝。在实际项目中，拷贝std::vector<char>并不是一个好的行为，他们更想要的是copy-on-write string、不可变string、基于引用计数的string等。在实际使用的过程中，std::string的最大问题就是它不适用于作为参数传递，因为它非常容易导致不必要的数据拷贝。此外，由于各个标注库实现的方式不同，会给跨平台一直带来风险，所以现在不少大型项目都会自己实现相关的string类。在实际使用过程中一般有以下替代品：</char></p>
<ul>
<li>boost::string_ref（chrome:StringPiece）</li>
<li>std::string_view(c++17后才可用)</li>
<li>不直接传递一个string，而是传递它的迭代器</li>
</ul>
<p>本文主要来分析GNU STL中std::string的实现，string_ref的实现可参考<a href="https://leeshine.github.io/2019/06/08/cpp-string2/" target="_blank" rel="noopener">string_ref的实现</a>，folly::FBString的实现可参考<a href="https://leeshine.github.io/2019/06/08/cpp-string3/" target="_blank" rel="noopener">FBString的实现</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>以<code>gcc-stl 4.4.0</code>为例std::string的实现方式，gnu-stl中string的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits = char_traits&lt;_CharT&gt;,</span><br><span class="line">         <span class="keyword">typename</span> _Alloc = allocator&lt;_CharT&gt; &gt;</span><br><span class="line">  class basic_string;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt;    <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，std::string是basic_string关于char的实现，下面来看basic_string的实现，如下为关于basic_string的部分说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*  A <span class="built_in">string</span> looks like <span class="keyword">this</span>:</span><br><span class="line">*</span><br><span class="line">*  @code</span><br><span class="line">*                                        [_Rep]</span><br><span class="line">*                                        _M_length <span class="comment">//长度</span></span><br><span class="line">*   [basic_string&lt;char_type&gt;]            _M_capacity <span class="comment">//容量</span></span><br><span class="line">*   _M_dataplus                          _M_refcount <span class="comment">//引用计数，使用了cow</span></span><br><span class="line">*   _M_p ----------------&gt;               unnamed <span class="built_in">array</span> of char_type <span class="comment">//指向实际的数据</span></span><br><span class="line">*  @endcode</span><br></pre></td></tr></table></figure>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>首先来看basic_string的构造函数，以最常见的std::string(“xxx”)这种构造方式为例来看它对应的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">   basic_string&lt;_CharT, _Traits, _Alloc&gt;::</span><br><span class="line">   basic_string(<span class="keyword">const</span> _CharT* __s, size_type __n, <span class="keyword">const</span> _Alloc&amp; __a)</span><br><span class="line">   : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)</span><br><span class="line">   &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>它调用<code>_S_construct</code>这个函数对<code>_M_dataplus</code>这个成员变量来进行初始化，<code>_M_dataplus</code>的定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="comment">// Use empty-base optimization: http://www.cantrip.org/emptyopt.html</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">Alloc_hider</span> :</span> _Alloc</span><br><span class="line">     &#123;</span><br><span class="line">_Alloc_hider(_CharT* __dat, <span class="keyword">const</span> _Alloc&amp; __a)</span><br><span class="line">: _Alloc(__a), _M_p(__dat) &#123; &#125;</span><br><span class="line"></span><br><span class="line">_CharT* _M_p; <span class="comment">// The actual data.</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">     <span class="comment">// Data Members (private):</span></span><br><span class="line">     <span class="keyword">mutable</span> _Alloc_hider	_M_dataplus;</span><br></pre></td></tr></table></figure></p>
<p>由此可见，<code>_M_dataplus</code>中包含指向实际数据的指针，前文也说到，basic_string中应该还包含有大小、容量等数据成员的，这部分数据成员是存在<code>_Rep</code>中的，basic_string只存储指向它的指针，从而将减少内存占用和避免额外的内存拷贝，它的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">Rep_base</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">size_type		_M_length;</span><br><span class="line">size_type		_M_capacity;</span><br><span class="line">_Atomic_word		_M_refcount;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">Rep</span> :</span> _Rep_base</span><br><span class="line">     &#123;</span><br><span class="line">       _CharT*</span><br><span class="line">         _M_refdata() <span class="keyword">throw</span>()</span><br><span class="line">         &#123; <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;_CharT*&gt;(<span class="keyword">this</span> + <span class="number">1</span>); &#125;<span class="comment">//获取指向的实际数据</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p><code>_S_construct</code>根据输入参数初始化<code>_M_dataplus</code>,定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InIterator&gt;</span><br><span class="line">      _CharT*</span><br><span class="line">      basic_string&lt;_CharT, _Traits, _Alloc&gt;::</span><br><span class="line">      _S_construct(_InIterator __beg, _InIterator __end, <span class="keyword">const</span> _Alloc&amp; __a,</span><br><span class="line">		   input_iterator_tag)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GLIBCXX_FULLY_DYNAMIC_STRING <span class="comment">//是否开启动态字符串，默认是开启的，即使用引用计数</span></span></span><br><span class="line">	<span class="keyword">if</span> (__beg == __end &amp;&amp; __a == _Alloc())</span><br><span class="line">	  <span class="keyword">return</span> _S_empty_rep()._M_refdata();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">// Avoid reallocation for common case.</span></span><br><span class="line">     <span class="comment">//当字符串较短时，直接将数据存在栈中，避免去申请动态内存空间</span></span><br><span class="line">	_CharT __buf[<span class="number">128</span>];</span><br><span class="line">	size_type __len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (__beg != __end &amp;&amp; __len &lt; <span class="keyword">sizeof</span>(__buf) / <span class="keyword">sizeof</span>(_CharT))</span><br><span class="line">	  &#123;</span><br><span class="line">	    __buf[__len++] = *__beg;</span><br><span class="line">	    ++__beg;</span><br><span class="line">	  &#125;</span><br><span class="line">     <span class="comment">//根据__len分配空间，初始化__r</span></span><br><span class="line">	_Rep* __r = _Rep::_S_create(__len, size_type(<span class="number">0</span>), __a);</span><br><span class="line">     <span class="comment">//将数据拷贝纸__r的指向位置</span></span><br><span class="line">	_M_copy(__r-&gt;_M_refdata(), __buf, __len);</span><br><span class="line">	__try</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">while</span> (__beg != __end)</span><br><span class="line">	      &#123;</span><br><span class="line">		<span class="keyword">if</span> (__len == __r-&gt;_M_capacity)</span><br><span class="line">		  &#123;</span><br><span class="line">		    <span class="comment">// Allocate more space.</span></span><br><span class="line">            <span class="comment">//分配更多内存，销毁老的指针</span></span><br><span class="line">		    _Rep* __another = _Rep::_S_create(__len + <span class="number">1</span>, __len, __a);</span><br><span class="line">		    _M_copy(__another-&gt;_M_refdata(), __r-&gt;_M_refdata(), __len);</span><br><span class="line">		    __r-&gt;_M_destroy(__a);</span><br><span class="line">		    __r = __another;</span><br><span class="line">		  &#125;</span><br><span class="line">		__r-&gt;_M_refdata()[__len++] = *__beg;</span><br><span class="line">		++__beg;</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	__catch(...)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __r-&gt;_M_destroy(__a);</span><br><span class="line">	    __throw_exception_again;</span><br><span class="line">	  &#125;</span><br><span class="line">    <span class="comment">// 返回指向的数据，及最终M_dataplus指向实际存储的数据</span></span><br><span class="line">	__r-&gt;_M_set_length_and_sharable(__len);</span><br><span class="line">	<span class="keyword">return</span> __r-&gt;_M_refdata();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>_Rep::_S_create</code>的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">   <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::_Rep*</span><br><span class="line">   basic_string&lt;_CharT, _Traits, _Alloc&gt;::_Rep::</span><br><span class="line">   _S_create(size_type __capacity, size_type __old_capacity,</span><br><span class="line">      <span class="keyword">const</span> _Alloc&amp; __alloc)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span> (__capacity &gt; _S_max_size)</span><br><span class="line">__throw_length_error(__N(<span class="string">"basic_string::_S_create"</span>));</span><br><span class="line"></span><br><span class="line">     <span class="comment">//对齐页面大小及头部大小，其中头部带下是malloc分配时内存页面对齐时所需要使用的</span></span><br><span class="line">     <span class="keyword">const</span> size_type __pagesize = <span class="number">4096</span>;</span><br><span class="line">     <span class="keyword">const</span> size_type __malloc_header_size = <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//一次扩大至少两倍容量，避免频繁的内存分配</span></span><br><span class="line">     <span class="keyword">if</span> (__capacity &gt; __old_capacity &amp;&amp; __capacity &lt; <span class="number">2</span> * __old_capacity)</span><br><span class="line">__capacity = <span class="number">2</span> * __old_capacity;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//多申请一个字节用以存储'\0'</span></span><br><span class="line">    size_type __size = (__capacity + <span class="number">1</span>) * <span class="keyword">sizeof</span>(_CharT) + <span class="keyword">sizeof</span>(_Rep);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//进行内存对齐的实际长度，需要加上头部长度</span></span><br><span class="line">    <span class="keyword">const</span> size_type __adj_size = __size + __malloc_header_size;</span><br><span class="line">     <span class="keyword">if</span> (__adj_size &gt; __pagesize &amp;&amp; __capacity &gt; __old_capacity)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//进行页面对齐</span></span><br><span class="line">  <span class="keyword">const</span> size_type __extra = __pagesize - __adj_size % __pagesize;</span><br><span class="line">  __capacity += __extra / <span class="keyword">sizeof</span>(_CharT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__capacity &gt; _S_max_size)</span><br><span class="line">    __capacity = _S_max_size;</span><br><span class="line">  __size = (__capacity + <span class="number">1</span>) * <span class="keyword">sizeof</span>(_CharT) + <span class="keyword">sizeof</span>(_Rep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//开辟内存</span></span><br><span class="line">     <span class="keyword">void</span>* __place = _Raw_bytes_alloc(__alloc).allocate(__size);</span><br><span class="line">     _Rep *__p = <span class="keyword">new</span> (__place) _Rep;</span><br><span class="line">     __p-&gt;_M_capacity = __capacity;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//启用引用计数</span></span><br><span class="line">     __p-&gt;_M_set_sharable();</span><br><span class="line">     <span class="keyword">return</span> __p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>到现在可以明白的是，<code>_Rep</code>中存储了前文说到的字符串长度、容量、引用计数等信息，同时会申请<code>__capacity + 1</code>大小的内存用以存储实际字符串内容。至此，整个basic_string的初始化机制就比较明朗了。</p>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>一个<code>std::string</code>的内存布局如下：</p>
<p><img src="/images/cpp/string_mem.png" alt=""></p>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>在gcc4.*版本中，basic_string的拷贝采用了<code>COW</code>机制，通过如下代码可以来验证：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> s1 = <span class="string">"s1"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">string</span> s2 = s1;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ((<span class="keyword">void</span>*)(s1.data()) == (<span class="keyword">void</span>*)(s2.data())) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  s2[<span class="number">0</span>] = <span class="string">'x'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ((<span class="keyword">void</span>*)(s1.data()) == (<span class="keyword">void</span>*)(s2.data())) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>GCC 4.8.5</code>上编译后的运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>由此可验证字符串拷贝默认是采用了<code>COW</code>机制，下面来看字符串拷贝的具体实现，它的拷贝构造函数为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">basic_string(<span class="keyword">const</span> basic_string&amp; __str)</span><br><span class="line">    : _M_dataplus(__str._M_rep()-&gt;_M_grab(_Alloc(__str.get_allocator()),</span><br><span class="line">					  __str.get_allocator()),</span><br><span class="line">		  __str.get_allocator())</span><br><span class="line">      </span><br><span class="line"> _CharT* _M_grab(<span class="keyword">const</span> _Alloc&amp; __alloc1, <span class="keyword">const</span> _Alloc&amp; __alloc2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (! _M_is_leaked() &amp;&amp; __alloc1 == __alloc2)</span><br><span class="line">        ? _M_refcopy() : _M_clone (__alloc1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_CharT*_M_refcopy() <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING</span><br><span class="line">    <span class="keyword">if</span> ( __builtin_expect(<span class="keyword">this</span> != &amp;_S_empty_rep(), <span class="literal">false</span>))</span><br><span class="line">#endif</span><br><span class="line">        __gnu_cxx::__atomic_add_dispatch (&amp;<span class="keyword">this</span>-&gt; _M_refcount, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _M_refdata();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终调用的<code>_M_refcopy</code>这个函数，将引用计数加1，然后将指针指向<code>_Rep</code>，下面来看实际的修改的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span> []( size_type __pos )</span><br><span class="line">&#123;</span><br><span class="line">    _M_leak();</span><br><span class="line">    <span class="keyword">return</span> _M_data ()[__pos ];<span class="comment">//其中,_M_data()用以获取_M_p</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _M_leak ()  <span class="comment">// for use in begin() &amp; non-const op[]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拷贝构造时_M_is_leaked都是为false，即是通过COW生成的，所以会调用_M_leak_hard</span></span><br><span class="line">    <span class="keyword">if</span> (! _M_rep ()-&gt;_M_is_leaked ())</span><br><span class="line">        _M_leak_hard ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _M_leak_hard ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( _M_rep ()-&gt;_M_is_shared ())</span><br><span class="line">        _M_mutate (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    _M_rep()-&gt; _M_set_leaked ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _M_mutate ( size_type __pos , size_type __len1, size_type __len2 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __old_size = <span class="keyword">this</span>-&gt; size ();</span><br><span class="line">    <span class="keyword">const</span> size_type __new_size = __old_size + __len2 - __len1 ;</span><br><span class="line">    <span class="keyword">const</span> size_type __how_much = __old_size - __pos - __len1 ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新生成_Rep,拷贝数据，引用数减1</span></span><br><span class="line">    <span class="keyword">if</span> ( __new_size &gt; <span class="keyword">this</span> -&gt; capacity() || _M_rep ()-&gt;_M_is_shared ())</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">const</span> allocator_type __a = get_allocator ();</span><br><span class="line">        _Rep * __r = _Rep:: _S_create (__new_size , <span class="keyword">this</span>-&gt; capacity (), __a );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__pos )</span><br><span class="line">            _M_copy (__r -&gt; _M_refdata(), _M_data (), __pos );</span><br><span class="line">        <span class="keyword">if</span> (__how_much )</span><br><span class="line">            _M_copy (__r -&gt; _M_refdata() + __pos + __len2 ,</span><br><span class="line">            _M_data () + __pos + __len1, __how_much );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用计数减1</span></span><br><span class="line">        _M_rep ()-&gt;_M_dispose ( __a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向新的_Rep</span></span><br><span class="line">        _M_data (__r -&gt; _M_refdata());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__how_much &amp;&amp; __len1 != __len2 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Work in-place.</span></span><br><span class="line">        _M_move (_M_data () + __pos + __len2 ,</span><br><span class="line">            _M_data () + __pos + __len1, __how_much );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置自身的引用计数</span></span><br><span class="line">    _M_rep()-&gt; _M_set_length_and_sharable (__new_size );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以数据拷贝的发生在数据实际修改的时候。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>basic_string仅仅包含一个成员<code>_M_dataplus</code>，它会指向一个<code>_Rep</code>的结构，<code>_Rep</code>中才会实际存放字符串的内容和长度等信息。初始化过程中，对于短字符串，会先存放在栈中，待生成<code>_Rep</code>指针后才会将数据拷贝至<code>_Rep</code>中，这样可以避免初始化短字符串的时候去申请动态内存空间</li>
<li><code>_Rep</code>中记录了basic_string的引用计数，在<code>GCC4.*</code>版本中，引用计数是默认开启的，所以对象的拷贝构造很快</li>
<li>因为basic_string中仅包含指向<code>_Rep</code>的指针这一个数据成员，所以<code>sizeof(std::string)</code>等于8，但是由于它还要为它分配<code>_Rep</code>，一个空<code>_Rep</code>的大小为25，所以在<code>GCC4.*</code>中一个空string的大小也为33个字节</li>
<li><code>COW</code>能有效减少内存拷贝，但是其实现较为复杂，也存在一些其他问题，具体可参考[<a href="[http://blogs.360.cn/post/linux-gcc-stl-string-in-depth.html](http://blogs.360.cn/post/linux-gcc-stl-string-in-depth.html">std::string的Copy-on-Write：不如想象中美好</a>)，加上新的标准库中<code>std::move</code>的引入导致<code>COW</code>的这种优化不再有不要，所以从GCC5开始已经废弃了<code>COW</code>机制</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://blog.csdn.net/ybxuwei/article/details/51326830" target="_blank" rel="noopener">std::string源码探秘和性能分析</a></li>
<li><a href="http://blogs.360.cn/post/linux-gcc-stl-string-in-depth.html" target="_blank" rel="noopener">深入剖析 linux GCC 4.4 的 STL string</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/17/tcp-reuse-addr-port/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/tcp-reuse-addr-port/" itemprop="url">TCP中SO_REUSEADDR及SO_REUSEPORT区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-17T07:50:41+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文主要讲述Linux下<code>SO_REUSEADDR</code>及<code>SO_REUSEPORT</code>这两个socket选项的用法及区别，不同平台下的实现可能不同</p>
</blockquote>
<p>众所周知，一个TCP/UDP连接是有如下一个五元组来确定的，没有两个连接是具有完全相同的五元组的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[协议，源地址，源端口，目的地址，目的端口]</span><br></pre></td></tr></table></figure>
<p>其中，协议部分是在创建socket指定的，源地址及源端口是服务端在<code>bind</code>时指定的，目的地址及目的端口是客户端通过<code>connect</code>时指定的。因为UDP是无连接的通信协议，一个UDP无需<code>connect</code>就使用，这种无连接的socket</p>
<p>在第一次发送数据的时候会有系统自动绑定一个五元组，否则的话该socket将无法接收任何数据。对于TCP连接同样是如此，系统会在连接建立之前隐式绑定一个五元组。</p>
<h2 id="SO-REUSEADDDR"><a href="#SO-REUSEADDDR" class="headerlink" title="SO_REUSEADDDR"></a>SO_REUSEADDDR</h2><p>无法将一个socket绑定值相同的五元组容易带来如下问题：</p>
<ul>
<li><code>TIME_WAIT</code>状态时间过长，造成期间socket的某个端口无法复用，这个问题在tcp server重启的时候尤其严重</li>
<li>通过<code>0.0.0.0</code>将socket绑定至本地任意一个地址后，其他本地地址将无法再使用</li>
</ul>
<p>在Linux中，<code>SO_REUSERADDR</code>就是用以解决这个问题的。假设某个主机有两个本地地址分别是<code>192.168.0.1</code>及<code>10.0.0.1</code>，对SocketA及SocketB通过不同方式绑定有如下结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">SO_REUSEADDR</th>
<th style="text-align:center">SocketA</th>
<th style="text-align:center">SocketB</th>
<th style="text-align:center">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ON/OFF</td>
<td style="text-align:center">192.168.0.1:21</td>
<td style="text-align:center">192.168.0.1:21</td>
<td style="text-align:center">Error(EADDRINUSE)</td>
</tr>
<tr>
<td style="text-align:center">ON/OFF</td>
<td style="text-align:center">192.168.0.1:21</td>
<td style="text-align:center">10.0.0.1:21</td>
<td style="text-align:center">Ok</td>
</tr>
<tr>
<td style="text-align:center">ON/OFF</td>
<td style="text-align:center">10.0.0.1:21</td>
<td style="text-align:center">192.168.0.1:21</td>
<td style="text-align:center">Ok</td>
</tr>
<tr>
<td style="text-align:center">OFF</td>
<td style="text-align:center">0.0.0.1:21</td>
<td style="text-align:center">192.168.0.1:21</td>
<td style="text-align:center">Error(EADDRINUSE)</td>
</tr>
<tr>
<td style="text-align:center">OFF</td>
<td style="text-align:center">192.168.0.1:21</td>
<td style="text-align:center">0.0.0.1:21</td>
<td style="text-align:center">Error(EADDRINUSE)</td>
</tr>
<tr>
<td style="text-align:center">ON</td>
<td style="text-align:center">0.0.0.1:21</td>
<td style="text-align:center">192.168.0.1:21</td>
<td style="text-align:center">Ok</td>
</tr>
<tr>
<td style="text-align:center">ON</td>
<td style="text-align:center">192.168.0.1:21</td>
<td style="text-align:center">0.0.0.1:21</td>
<td style="text-align:center">Ok</td>
</tr>
<tr>
<td style="text-align:center">ON/OFF</td>
<td style="text-align:center">0.0.0.1:21</td>
<td style="text-align:center">0.0.0.1:21</td>
<td style="text-align:center">Error(EADDRINUSE)</td>
</tr>
</tbody>
</table>
<h2 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a>SO_REUSEPORT</h2><p>如上文所述，<code>SO_REUSEADDR</code>选项并不是用以将socket真正绑定至同一五元组的，Linux在3.9版本之后添加了新选项<code>SO_REUSEPORT</code>，通过该选项，不同线程或者进程就可以绑定至同一端口。其中需要注意的是，所以绑定至该端口的socket都需设置<code>SO_REUSEPORT</code>选项，否则将会绑定失败。同时基于安全性考虑，第一个进程绑定后，后续需要板顶至该端口的进程所属用户要么是root用户，要么是跟第一个进程归属于同一用户。</p>
<p>网络服务中一种常见的模式是用一个listen线程来接收连接后将分配工作线程来处理新连接，这种模式下listen线程容易存在瓶颈。为了解决这种问题，第二种常见模式是运行多个进程来对循环监听一个端口。在没有<code>SO_REUSEPORT</code>选项之前，是通过<code>fork</code>来实现的，父进程绑定至一个端口后，fork出多个子进程来循环监听这个socket。但是这种模式存在一个问题，当有新连接到来时，那个进程能成功获取到这个连接呢？在Linux 2.6.18之前，所有监听的进程都会被唤醒，但只有一个进程能成功获取到这个连接，这既是<code>accept惊群</code>问题，在Linux2.6.18之后的版本已经修复了这个问题。但是如果使用epoll去监听<code>accept socket</code>上的可读事件，仍会存在惊群问题。</p>
<p>有了<code>SO_REUSEPORT</code>选项，我们就可以不通过fork的方式来让多个进程监听统一端口，这样每个进程中的socket fd是不一样的，自然也就不会存在惊群问题。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://blog.qiusuo.im/blog/2014/09/14/linux-so-reuseport/" target="_blank" rel="noopener">Linux中SO_REUSEADDR和SO_REUSEPORT区别</a></li>
</ul>
<ul>
<li><a href="http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t/14388707#14388707" target="_blank" rel="noopener">Difference between SO_REUSEADDR and SO_REUSEPORT</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/17/stack-of-fuc-call/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/stack-of-fuc-call/" itemprop="url">C++函数调用栈过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-17T07:36:38+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="函数压栈过程"><a href="#函数压栈过程" class="headerlink" title="函数压栈过程"></a>函数压栈过程</h2><p>以如下代码为例来分析C++中函数调用过程中，栈是如何变化的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> sp1, <span class="keyword">int</span> sp2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = sp1 + sp2;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res =  foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Linux进程的地址空间中，栈是位于进程的高地址位置，且栈顶是向下增长的，每次的函数调用都有它自己独立的一个栈帧，用以记录这个函数调用过程中所需的信息，包括函数返回地址、参数、临时变量、保存的上下文等。其中有两个寄存器非常重要，分别<code>esp</code>和<code>ebp</code>，分别记录当前栈帧的栈顶位置和栈底位置，（对于<code>X86-64</code>平台上来说，对应的寄存器则为<code>rsp</code>及<code>rbp</code>），压栈使<code>esp</code>变小。一个典型的栈帧如下所示：</p>
<p><img src="/images/linux/stack1.png" alt=""></p>
<p>从参数开始的数据即是当前函数的栈帧，<code>ebp</code>的位置在运行过程中是固定的，而<code>esp</code>始终指向栈顶，在运行过程中是会发生变化的，而参数及返回地址之所以在<code>ebp</code>之上是因为这个两项是由该函数的调用者进行压栈的。<code>ebp</code>指向的<code>old ebp</code>是函数调用者的<code>ebp</code>值，这样该函数退出后通过<code>old ebp</code>即可恢复调用者的栈帧。</p>
<p>将示例代码编译后，通过gdb进行反汇编，首先来看<code>main</code>函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   <span class="number">0x0000000000400830</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp </span><br><span class="line">   <span class="number">0x0000000000400831</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000000400834</span> &lt;+<span class="number">4</span>&gt;:	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x0000000000400838</span> &lt;+<span class="number">8</span>&gt;:	mov    $<span class="number">0x2</span>,%esi #将foo第二个参数存入寄存器中</span><br><span class="line">   <span class="number">0x000000000040083d</span> &lt;+<span class="number">13</span>&gt;:	mov    $<span class="number">0x1</span>,%edi #将foo的第一个参数存入寄存器中</span><br><span class="line">   <span class="number">0x0000000000400842</span> &lt;+<span class="number">18</span>&gt;:	callq  <span class="number">0x400816</span> &lt;foo(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; # 调用foo</span><br><span class="line">   <span class="number">0x0000000000400847</span> &lt;+<span class="number">23</span>&gt;:	mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   <span class="number">0x000000000040084a</span> &lt;+<span class="number">26</span>&gt;:	mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">   <span class="number">0x000000000040084d</span> &lt;+<span class="number">29</span>&gt;:	mov    %eax,%esi</span><br><span class="line">   <span class="number">0x000000000040084f</span> &lt;+<span class="number">31</span>&gt;:	mov    $<span class="number">0x601060</span>,%edi</span><br><span class="line">   <span class="number">0x0000000000400854</span> &lt;+<span class="number">36</span>&gt;:	callq  <span class="number">0x4006a0</span> &lt;_ZNSolsEi@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400859</span> &lt;+<span class="number">41</span>&gt;:	mov    $<span class="number">0x400700</span>,%esi</span><br><span class="line">   <span class="number">0x000000000040085e</span> &lt;+<span class="number">46</span>&gt;:	mov    %rax,%rdi</span><br><span class="line">   <span class="number">0x0000000000400861</span> &lt;+<span class="number">49</span>&gt;:	callq  <span class="number">0x4006f0</span> &lt;_ZNSolsEPFRSoS_E@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400866</span> &lt;+<span class="number">54</span>&gt;:	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x000000000040086b</span> &lt;+<span class="number">59</span>&gt;:	leaveq </span><br><span class="line">   <span class="number">0x000000000040086c</span> &lt;+<span class="number">60</span>&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>可以看到，参数是在调用foo之前传入的，参数可能是通过压栈的方式传入，也可能是通过寄存器传递，其中<code>call</code>指令用以调用<code>foo</code>函数，该指令也会将函数的返回地址进行压栈。下面来对foo进行反汇编，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble foo</span><br><span class="line">Dump of assembler code for function foo(int, int):</span><br><span class="line">   <span class="number">0x0000000000400816</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp #将老的rbp压栈</span><br><span class="line">   <span class="number">0x0000000000400817</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp # 将rbp指向rsp</span><br><span class="line">   <span class="number">0x000000000040081a</span> &lt;+<span class="number">4</span>&gt;:	mov    %edi,<span class="number">-0x14</span>(%rbp) #参数<span class="number">1</span>入栈</span><br><span class="line">   <span class="number">0x000000000040081d</span> &lt;+<span class="number">7</span>&gt;:	mov    %esi,<span class="number">-0x18</span>(%rbp) #参数<span class="number">2</span>入栈</span><br><span class="line">   <span class="number">0x0000000000400820</span> &lt;+<span class="number">10</span>&gt;:	mov    <span class="number">-0x14</span>(%rbp),%edx #参数<span class="number">1</span>存入edx</span><br><span class="line">   <span class="number">0x0000000000400823</span> &lt;+<span class="number">13</span>&gt;:	mov    <span class="number">-0x18</span>(%rbp),%eax #参数存<span class="number">2</span>入eax</span><br><span class="line">   <span class="number">0x0000000000400826</span> &lt;+<span class="number">16</span>&gt;:	add    %edx,%eax #执行加法运算，结果存储在eax中</span><br><span class="line">   <span class="number">0x0000000000400828</span> &lt;+<span class="number">18</span>&gt;:	mov    %eax,<span class="number">-0x4</span>(%rbp) #将运算结果赋值给result,它的位置为rbp<span class="number">-4</span></span><br><span class="line">   <span class="number">0x000000000040082b</span> &lt;+<span class="number">21</span>&gt;:	mov    <span class="number">-0x4</span>(%rbp),%eax #将result赋值给eax，eax为函数返回值</span><br><span class="line">   <span class="number">0x000000000040082e</span> &lt;+<span class="number">24</span>&gt;:	pop    %rbp #从栈中恢复保存的rbp,即恢复函数调用者的栈帧</span><br><span class="line">   <span class="number">0x000000000040082f</span> &lt;+<span class="number">25</span>&gt;:	retq  #从栈中取到返回地址，并跳转到该位置</span><br></pre></td></tr></table></figure>
<p>从上述代码也可总结出，c++中一个函数调用(<code>foo</code>)过程是这样的：</p>
<ol>
<li>把该函数的所有或者部分参数入栈，或者将参数存入寄存器中</li>
<li>把当前指令的下一条指令压如栈中</li>
<li>跳转到函数<code>foo</code>内部执行</li>
<li>将调用者的<code>ebp</code>值压栈保存(<code>push ebp</code>)</li>
<li>重置<code>foo</code>函数的栈帧(<code>mov ebp esp</code>)</li>
<li>执行相关操作</li>
<li>执行完函数<code>foo</code>之后，恢复调用者的栈帧（<code>pop ebp</code>)</li>
<li>跳转到下一指令继续执行</li>
</ol>
<h2 id="函数返回值传递"><a href="#函数返回值传递" class="headerlink" title="函数返回值传递"></a>函数返回值传递</h2><p>通过前文的发汇编代码也可看到，函数的返回值是通过<code>eax</code>来返回的，但是<code>eax</code>只能存储4个字节，那么对于大于4个字节的返回值是如何传递的呢，以如下代码为例来看:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test4Bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">test8Bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">12345678901l</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> l1;</span><br><span class="line">  <span class="keyword">long</span> l2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">testMoreBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node n1;</span><br><span class="line">  n1.l1 = <span class="number">1234567889l</span>;</span><br><span class="line">  n1.l2 = <span class="number">1234567889l</span>;</span><br><span class="line">  <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> s1 = test4Bytes();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">long</span> s2 = test8Bytes();</span><br><span class="line"></span><br><span class="line">   node s3 = testMoreBytes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>函数的反汇编结果如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   <span class="number">0x000000000040077e</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp</span><br><span class="line">   <span class="number">0x000000000040077f</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000000400782</span> &lt;+<span class="number">4</span>&gt;:	sub    $<span class="number">0xa0</span>,%rsp</span><br><span class="line">   <span class="number">0x0000000000400789</span> &lt;+<span class="number">11</span>&gt;:	mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">   <span class="number">0x0000000000400792</span> &lt;+<span class="number">20</span>&gt;:	mov    %rax,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">   <span class="number">0x0000000000400796</span> &lt;+<span class="number">24</span>&gt;:	xor    %eax,%eax</span><br><span class="line">   <span class="number">0x0000000000400798</span> &lt;+<span class="number">26</span>&gt;:	callq  <span class="number">0x400726</span> &lt;test4Bytes()&gt;</span><br><span class="line">   <span class="number">0x000000000040079d</span> &lt;+<span class="number">31</span>&gt;:	mov    %eax,<span class="number">-0x9c</span>(%rbp)</span><br><span class="line">   <span class="number">0x00000000004007a3</span> &lt;+<span class="number">37</span>&gt;:	callq  <span class="number">0x400731</span> &lt;test8Bytes()&gt;</span><br><span class="line">   <span class="number">0x00000000004007a8</span> &lt;+<span class="number">42</span>&gt;:	mov    %rax,<span class="number">-0x98</span>(%rbp)</span><br><span class="line">   <span class="number">0x00000000004007af</span> &lt;+<span class="number">49</span>&gt;:	lea    <span class="number">-0x90</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x00000000004007b6</span> &lt;+<span class="number">56</span>&gt;:	mov    %rax,%rdi</span><br><span class="line">   <span class="number">0x00000000004007b9</span> &lt;+<span class="number">59</span>&gt;:	callq  <span class="number">0x400741</span> &lt;testMoreBytes()&gt;</span><br><span class="line">   <span class="number">0x00000000004007be</span> &lt;+<span class="number">64</span>&gt;:	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x00000000004007c3</span> &lt;+<span class="number">69</span>&gt;:	mov    <span class="number">-0x8</span>(%rbp),%rdx</span><br><span class="line">   <span class="number">0x00000000004007c7</span> &lt;+<span class="number">73</span>&gt;:	xor    %fs:<span class="number">0x28</span>,%rdx</span><br><span class="line">   <span class="number">0x00000000004007d0</span> &lt;+<span class="number">82</span>&gt;:	je     <span class="number">0x4007d7</span> &lt;main()+<span class="number">89</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004007d2</span> &lt;+<span class="number">84</span>&gt;:	callq  <span class="number">0x400610</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   <span class="number">0x00000000004007d7</span> &lt;+<span class="number">89</span>&gt;:	leaveq </span><br><span class="line">   <span class="number">0x00000000004007d8</span> &lt;+<span class="number">90</span>&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>从<code>main</code>函数的反汇编结果也可看出，前两个函数是分别是通过<code>eax</code>及<code>rax</code>来返回的。首先来看<code>test4Bytes</code>，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble test4Bytes</span><br><span class="line">Dump of assembler code for function test4Bytes():</span><br><span class="line">   <span class="number">0x0000000000400726</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp</span><br><span class="line">   <span class="number">0x0000000000400727</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x000000000040072a</span> &lt;+<span class="number">4</span>&gt;:	mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">   <span class="number">0x000000000040072f</span> &lt;+<span class="number">9</span>&gt;:	pop    %rbp</span><br><span class="line">   <span class="number">0x0000000000400730</span> &lt;+<span class="number">10</span>&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>如前文所述，4个字节的函数返回值是通过<code>eax</code>来传递的。而<code>test8Bytes</code>的反汇编结果如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble test8Bytes</span><br><span class="line">Dump of assembler code for function test8Bytes():</span><br><span class="line">   <span class="number">0x0000000000400731</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp</span><br><span class="line">   <span class="number">0x0000000000400732</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000000400735</span> &lt;+<span class="number">4</span>&gt;:	movabs $<span class="number">0x2dfdc1c35</span>,%rax</span><br><span class="line">   <span class="number">0x000000000040073f</span> &lt;+<span class="number">14</span>&gt;:	pop    %rbp</span><br><span class="line">   <span class="number">0x0000000000400740</span> &lt;+<span class="number">15</span>&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>可以看出，此时8个字节的返回值是通过<code>rax</code>来返回的，这个对于不同平台的实现来说可能是不一样的，例如在32位的机器上，一般是通过<code>eax</code>和<code>edx</code>组合来返回8个字节的返回值。上述<code>main</code>函数的反汇编代码中有段保护机制，为了简化无关代码的干绕，关闭端保护机制编译如下代码(<code>g++ -fno-stack-protector</code> )：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">testMoreBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node n1;</span><br><span class="line">  n1.buf[<span class="number">0</span>] = <span class="string">'c'</span>;</span><br><span class="line">  <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   node s3 = testMoreBytes();</span><br><span class="line"></span><br><span class="line">   s3.buf[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 相应的反汇编结果分别为：</span><br><span class="line">(gdb) disassemble  main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x00000000004006e7</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp</span><br><span class="line">   <span class="number">0x00000000004006e8</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x00000000004006eb</span> &lt;+<span class="number">4</span>&gt;:	sub    $<span class="number">0x40</span>,%rsp</span><br><span class="line">   <span class="number">0x00000000004006ef</span> &lt;+<span class="number">8</span>&gt;:	lea    <span class="number">-0x40</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x00000000004006f3</span> &lt;+<span class="number">12</span>&gt;:	mov    %rax,%rdi</span><br><span class="line">   <span class="number">0x00000000004006f6</span> &lt;+<span class="number">15</span>&gt;:	callq  <span class="number">0x4006d1</span> &lt;_Z13testMoreBytesv&gt;</span><br><span class="line">   <span class="number">0x00000000004006fb</span> &lt;+<span class="number">20</span>&gt;:	movb   $<span class="number">0x61</span>,<span class="number">-0x40</span>(%rbp)</span><br><span class="line">   <span class="number">0x00000000004006ff</span> &lt;+<span class="number">24</span>&gt;:	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000000400704</span> &lt;+<span class="number">29</span>&gt;:	leaveq </span><br><span class="line">   <span class="number">0x0000000000400705</span> &lt;+<span class="number">30</span>&gt;:	retq  </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disassemble testMoreBytes</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function _Z13testMoreBytesv:</span><br><span class="line">   <span class="number">0x00000000004006d1</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp</span><br><span class="line">   <span class="number">0x00000000004006d2</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x00000000004006d5</span> &lt;+<span class="number">4</span>&gt;:	mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">   <span class="number">0x00000000004006d9</span> &lt;+<span class="number">8</span>&gt;:	mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x00000000004006dd</span> &lt;+<span class="number">12</span>&gt;:	movb   $<span class="number">0x63</span>,(%rax)</span><br><span class="line">   <span class="number">0x00000000004006e0</span> &lt;+<span class="number">15</span>&gt;:	nop</span><br><span class="line">   <span class="number">0x00000000004006e1</span> &lt;+<span class="number">16</span>&gt;:	mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x00000000004006e5</span> &lt;+<span class="number">20</span>&gt;:	pop    %rbp</span><br><span class="line">   <span class="number">0x00000000004006e6</span> &lt;+<span class="number">21</span>&gt;:	retq    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>从<code>main</code>的反汇编结果可以看出，它先是分配了64字节的一个堆栈空间，然后将该地址空间保存在<code>rax</code>中，然后将<code>rax</code>的值传入<code>rdi</code>中，紧接着便调用<code>testMoreBytes</code>函数，显而易见的是它是要将分配的这一段空间传递给<code>testMoreBytes</code>函数。而通过<code>testMoreBytes</code>的反汇编结果可以看出，它显示从<code>rdi</code>中取出这段地址，并将地址赋值给<code>rax</code>，最后再将值拷贝到这段地址空间处，所以此时函数返回值的传递过程是：</p>
<ol>
<li><code>main</code>函数会在堆栈中额外开辟一段空间，用以存储返回值</li>
<li>将上述空间的地址传递给<code>testMoreBytes</code>函数，函数内部将值拷贝到该空间处</li>
<li><code>main</code>函数通过该端空间来读取返回值</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/close-socket-gracefully/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/close-socket-gracefully/" itemprop="url">TCP连接的优雅关闭</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-09T23:21:52+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文主要参照MSDN文档，以windows为例，讲述TCP连接的优雅关闭，Linux也是同理</p>
</blockquote>
<p>本文主要讨论TCP连接中socket的优雅关闭，在实际使用时，明白关闭一个socket连接(<code>socket connection</code>)及关闭一个socket自身的区别是很重要的。</p>
<p>关闭一个socket连接(<code>shutdown a socket connection</code>)需要连接双方进行信息交互，这个交互即是关闭序列<code>shutdown sequence</code>，这中序列主要分为两种：优雅退出及强制退出。在优雅关闭中，任何已经在队列中但尚未发出的数据可以在连接被真正关闭之前被发出，而在强制退出中，任何未被发送的数据都会被丢弃。同时关闭序列也可以用来给相关应用程序发送<code>FD_CLOSE</code>指令，用以表示正在进行关闭连接操作。</p>
<p>而关闭一个socket本身(<code>close a socket</code>)是将这个socket删除，使得之后没有任何应用可以再使用该socket。</p>
<p>在Windows编程中，<code>shutdown</code>及<code>WSASendDisconnect</code>这两个函数都可以用来初始化一个关闭序列，而<code>closesocket</code>这个函数用以释放一个socket句柄并回收对应的资源。然而容易造成疑惑的是，再调用<code>closesocket</code>时，如果还没有关闭序列产生，该函数也会隐式生成一个关闭序列。事实上，依赖此特性来使用<code>closesocket</code>来生成一个关闭序列和回收句柄已经成为一个非常常见的用法。为了简化使用，socket编程接口会提供相应机制供使用者指定是产生优雅关闭序列还是强制关闭序列，以及<code>closesocket</code>函数是否应等待（<code>linger</code>，不是立即关闭）优雅关闭的完成。</p>
<p>通过为<code>SO_LINGER</code>及<code>SO_DONTLINGER</code>这两个选项设置合适的值，<code>closesocket</code>可以具有以下行为：</p>
<ul>
<li>生成强制关闭序列，<code>closesocket</code>函数立即返回</li>
<li>优雅关闭，<code>closesocket</code>函数会等待优雅关闭完成或者直到超时时间，如果超时后优雅关闭还未完成，就会产生一个强制关闭序列，此后函数会返回</li>
<li>优雅关闭，但是函数立即返回，在后台执行优雅关闭任务，这也是windows及Linux中的默认行为，然而这种模式下，应用程序是无法知道优雅关闭是否完成了</li>
</ul>
<p>其中，<code>linger</code>的使用方式及具体含义可参考<a href="https://leeshine.github.io/2019/03/09/so-linger" target="_blank" rel="noopener">SO_LINGER选项使用方式</a></p>
<p>为了减少关闭TCP连接过程中可能产生的问题，我们应该尽量避免依赖<code>closesocket</code>来隐式调用<code>shutdown</code>，而是现实调用<code>shutdown</code>或者<code>WSASendDisconnect</code>来关闭连接。这样可以是对端应用程序收到<code>FD_CLOSE</code>指令，标识所有数据都已发送。</p>
<p>总体来说，如下表所示展示了应该如何优雅关闭一个TCP连接：</p>
<table>
<thead>
<tr>
<th style="text-align:center">客户端侧</th>
<th style="text-align:center">服务端侧</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. 调用<code>shutdown(s, SD_SEND)</code>来关闭一个连接，同时表明自身再无数据需要发送</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">2. 接收到<code>FD_CLOSE</code>事件，表示有优雅关闭正在进行，同时所有数据都已经达到</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">3. 将服务端待发送数据都发送给客户端</td>
</tr>
<tr>
<td style="text-align:center">(时间上同右侧无必然联系)获取到<code>FD_READ</code>事件</td>
<td style="text-align:center">4. 调用<code>shutdown(s, SD_SEND)</code>，表明服务端以无数据需要发送</td>
</tr>
<tr>
<td style="text-align:center">5. 收到<code>FD_CLOSE</code>事件</td>
<td style="text-align:center">调用<code>closesocket</code>（时间上同左侧无必然联系）</td>
</tr>
<tr>
<td style="text-align:center">调用<code>closesocket</code></td>
</tr>
</tbody>
</table>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/winsock/graceful-shutdown-linger-options-and-socket-closure-2" target="_blank" rel="noopener">Graceful Shutdown, Linger Options, and Socket Closure</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/so-linger/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/so-linger/" itemprop="url">SO_LINGER选项使用方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-09T23:19:03+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文主要参照MSDN文档，以windows为例，讲述socket编程中<code>SO_LINGER</code>选项的使用</p>
</blockquote>
<p>SO_LINGER选项用以用以设定一个socket在关闭时队列中的待发送数据如何处理以及<code>closesocket</code>函数，该结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">  u_short l_onoff;</span><br><span class="line">  u_short l_linger;</span><br><span class="line">&#125; LINGER, *PLINGER, *LPLINGER;</span><br></pre></td></tr></table></figure>
<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="l-onoff"><a href="#l-onoff" class="headerlink" title="l_onoff"></a>l_onoff</h3><p>标识在调用<code>closesocket</code>后该socket是否仍停留一段时间从而使得队列中的数据发送出去，这个成员可以有如下取值:</p>
<table>
<thead>
<tr>
<th style="text-align:center">取值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">close函数立即返回，socket关闭，数据由后台发送，应用层不再知晓</td>
</tr>
<tr>
<td style="text-align:center">非0</td>
<td style="text-align:center">socket会停留一段时间</td>
</tr>
</tbody>
</table>
<h3 id="l-linger"><a href="#l-linger" class="headerlink" title="l_linger"></a>l_linger</h3><table>
<thead>
<tr>
<th style="text-align:center">取值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">close函数立即返回，数据丢弃，发送<code>RST</code>报文该服务端，服务端收到后立即管理连接，这样可以不经过四次挥手来关闭连接</td>
</tr>
<tr>
<td style="text-align:center">非0</td>
<td style="text-align:center">close函数阻塞到超时时间，若为发送完成则发送<code>RST</code>报文</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/07/hardware-architecture/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/hardware-architecture/" itemprop="url">内存知识之现代商用硬件架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-07T20:29:13+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CPU架构"><a href="#CPU架构" class="headerlink" title="CPU架构"></a>CPU架构</h2><p>早期时，个人电脑及小型服务器的架构如下：所有CPU之间是通过FSB（Front Side Bus， FSB）进行相互连接，并通过它来连接北桥，北桥连接高速设备（如主存等），通过北桥可以连接南桥，南迁连接低速设备（如硬盘、外设等）。</p>
<p><img src="/images/linux-memory/pic1.png" alt=""></p>
<p>这样的架构有这样一些特点：</p>
<ul>
<li>CPU之间的交互需要共用连接比较的总线（FSB）</li>
<li>每个RAM只有一个接口</li>
<li>CPU同主存之间的交互要通过北桥</li>
<li>CPU同南桥上的设备间的交互必须通过北桥</li>
</ul>
<p>这样的一个架构容易引入这样一些瓶颈：</p>
<ul>
<li>第一个瓶颈是对RAM的访问。早期时，所有设备的交互都要通过CPU来进行，这样会严重影响整个系统的性能。为了解决这个问题，直接内存访问（DMA，direct memory access ）技术被发明出来了，DMA允许外设通过北桥直接同RAM进行交互。这样能极大降低CPU负载，提升系统整体性能。</li>
<li>第二个瓶颈是通过从北桥连接RAM的总线。早期时系统是通过一条总线来连接所有RAM，所以无法并行访问内存，最近的RAM都支持多条总线连接来提升内存访问带宽</li>
</ul>
<p>但内存访问带宽受限时，合理安排内存访问顺序对于提升系统性能是非常重要的。众所周知，即使使用了CPU缓存后，CPU的运行速度（内部寄存器的访问速度）也比主存的访问速度快多了。如果多个线程、CPU核心、CPU处理器同时访问某块内存，那么整体的内存访问延迟是很高的。在一些现代系统中，在北桥上不是直接连接RAM，而是会连接一些外部内存分配器，如下所示：</p>
<p><img src="/images/linux-memory/pic2.png" alt=""></p>
<p>这个架构的好处是有多个内存总线存在，能提升整体的内存访问带宽，同时能提升系统的内存总量，并且通过访问不同内存条的方式可以降低并发内存访问的延迟。此时，系统的整体内存访问带宽主要受限于北桥的传输速度，这即使传统SMP（对称多核处理器）架构。</p>
<p>在北桥之间接入多个外部内存分配器并不是提升内存访问带宽的唯一方法，在一些系统中，内存分配器被放入CPU中，内存条也是直连每个CPU的，如下所示：</p>
<p><img src="/images/linux-memory/pic3.png" alt=""></p>
<p>这就是NUMA（非均匀性内存访问）架构，采用这种架构也有这样的问题：</p>
<ul>
<li>内存访问不再是对称的，本地内存还能以正常的速度访问，然而访问其他处理的内存需要通过对应的CPU来进行交互，这样会导致访问远程内存的速度较慢</li>
</ul>
<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="随机访问存储器（RAM）"><a href="#随机访问存储器（RAM）" class="headerlink" title="随机访问存储器（RAM）"></a>随机访问存储器（RAM）</h3><p>RAM分为两类：静态随机访问存储器（SRAM）和动态随机访问存储器（DRAM）。SRAM比DRAM访问速度快得多，但也更加昂贵，SRAM通常都是用来做高速缓存，DRAM通常用来做主存。SRAM与DRAM都是易失性存储，只要断电，其中存储的数据便会丢失。</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘是应用最广的数据存储设备，容量比RAM大得多，但是访问延迟也高。从磁盘读取信息时间为ms级别，DRAM的访问速度比磁盘快10万倍，而SRAM比磁盘快100万倍。</p>
<p>磁盘是由盘片构成的，每个盘片有两面被称之为表面，盘片中央有一个可旋转的主轴，盘片以固定速率围绕主轴旋转，如下图所示展示了一个典型的磁盘结构：</p>
<p><img src="/images/linux-memory/pic6.png" alt=""></p>
<p>每个表面由一组称为磁道的同心圆组成，每个磁道被划分为一组扇区，扇区间由间隙隔开，扇区是磁盘存储的最小单位，柱面是所有表面上到主轴距离相等的磁道的集合。</p>
<p>磁盘以扇区为基本单位，使用磁头来读写盘面上的数据，对扇区的访问时间主要由一下三个部分组成：</p>
<ul>
<li>寻道时间：磁头移动到目标扇区所在磁道的位置</li>
<li>旋转时间：盘面旋转将目标扇区转到到磁头下</li>
<li>传送时间：磁头读取扇区中的数据</li>
</ul>
<p>相对来说，传送时间远小于寻道时间和旋转时间，这也是为什么硬盘的顺序读写要比随机读写速度快得多。因为寻道时间和旋转时间大致是相等的，所以将寻道时间乘于2是估计磁盘访问时间的简单办法。</p>
<h3 id="固态硬盘（ssd）"><a href="#固态硬盘（ssd）" class="headerlink" title="固态硬盘（ssd）"></a>固态硬盘（ssd）</h3><p>固态硬盘是一种基于闪存的技术，相对磁盘来说，ssd上随机访问的速度较顺序访问的速度不会相差太多。</p>
<h2 id="各级存储设备访问延迟"><a href="#各级存储设备访问延迟" class="headerlink" title="各级存储设备访问延迟"></a>各级存储设备访问延迟</h2><p>以一个CPU时钟周期为单位，各级设备的访问延迟如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">设备</th>
<th style="text-align:center">延迟（时钟周期）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">L1</td>
<td style="text-align:center">2~3</td>
</tr>
<tr>
<td style="text-align:center">L2</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">L3</td>
<td style="text-align:center">30~40</td>
</tr>
<tr>
<td style="text-align:center">Memory</td>
<td style="text-align:center">100~200</td>
</tr>
<tr>
<td style="text-align:center">Disk</td>
<td style="text-align:center">1亿~2亿（30ms）左右</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/data-reaches-disk/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeshine">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leesine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/data-reaches-disk/" itemprop="url">确保数据到达磁盘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-26T21:04:37+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文主要讲述在Linux服务上数据从应用层写入磁盘的关键路径，聚焦于其中涉及到的各种缓存，讲述在c编程中如何确保数据能被持久化存储，避免系统异常时造成数据丢失。</p>
</blockquote>
<h2 id="IO-buffering"><a href="#IO-buffering" class="headerlink" title="IO buffering"></a>IO buffering</h2><p>Linux下，用户数据在最终达到持久化存储层之前会经过多层，如下所示：</p>
<p><img src="/images/linux/io-ac.png" alt=""></p>
<p>最顶层是需要存入数据的应用，数据首先是以block的方式存储在应用本身的memory或者buffer中，这些buffer也可能会被转交给运行库，由运行库来管理这些缓存。无论这些数据是在应用程序本身的buffer或者运行库的buffer中，此时这些数据都还是停留在用户地址空间。用户空间的下一层是内核空间，它也会内存中维护自身的写回缓存，即page cache。脏页在page cache中停留一段时间后会被写入存储设备中（如硬盘）。同时存储设备也可能会维护自身的易失性缓存，在掉电时缓存中的数据是会丢失的。最后，在最底层的是非易失性存储设备，数据只有在到达此层时，才是安全的，不会在系统异常退出时丢失。</p>
<p>为了更详细阐述如上所述的各种缓存机制，以这样的一个应用程序为例：它通过一个socket读入数据后将数据写入本地文件中。在关闭这个socket之前，服务端会确认数据已经持久化存储，主要代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">int</span></span><br><span class="line"> <span class="number">1</span> sock_read(<span class="keyword">int</span> sockfd, FILE *outfp, <span class="keyword">size_t</span> nrbytes)</span><br><span class="line"> <span class="number">2</span> &#123;</span><br><span class="line"> <span class="number">3</span>      <span class="keyword">int</span> ret;</span><br><span class="line"> <span class="number">4</span>      <span class="keyword">size_t</span> written = <span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span>      <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(MY_BUF_SIZE);</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span>      <span class="keyword">if</span> (!buf)</span><br><span class="line"> <span class="number">8</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="number">9</span></span><br><span class="line"><span class="number">10</span>      <span class="keyword">while</span> (written &lt; nrbytes) &#123;</span><br><span class="line"><span class="number">11</span>              ret = read(sockfd, buf, MY_BUF_SIZE);</span><br><span class="line"><span class="number">12</span>              <span class="keyword">if</span> (ret =&lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">13</span>                      <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="number">14</span>                              <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">15</span>                      <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">16</span>              &#125;</span><br><span class="line"><span class="number">17</span>              written += ret;</span><br><span class="line"><span class="number">18</span>              ret = fwrite((<span class="keyword">void</span> *)buf, ret, <span class="number">1</span>, outfp);</span><br><span class="line"><span class="number">19</span>              <span class="keyword">if</span> (ret != <span class="number">1</span>)</span><br><span class="line"><span class="number">20</span>                      <span class="keyword">return</span> ferror(outfp);</span><br><span class="line"><span class="number">21</span>      &#125;</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>      ret = fflush(outfp);</span><br><span class="line"><span class="number">24</span>      <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line"><span class="number">25</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span>      ret = fsync(fileno(outfp));</span><br><span class="line"><span class="number">28</span>      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">29</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">30</span>      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">31</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在接受client端的连接之后，应用会将从socket中读出的数据写入自身buffer之中，如上函数的调用者在调用前已经知道client端发送的数据大小，同时打开一个文件流用以写入数据，该函数在返回前会确认将数据持久化存储。<br>其中L5就是一个应用层的buffer，从socket中读出的数据首先会放入这个buffer中，同时鉴于网络传输的突发性或者低效，我们决定使用libc的流式函数（<code>fwrite()</code>及<code>fflush()</code>,代表上图中的运行库缓存）来缓存应用层读出的数据。L10-21就是用于从socket读出数据并写入文件流中，L23用以将文件流进行刷写，使数据进入内核空间。之后，在L27，数据被写入上图的<code>Stable Storage</code>这层。</p>
<h2 id="IO-APIs"><a href="#IO-APIs" class="headerlink" title="IO APIs"></a>IO APIs</h2><p>下面我们来看各个API同上图中每层的关系，在下面的讨论中，我们将IO分成3类：系统IO（system IO）、流式IO以及内存映射IO（mmap）。</p>
<h3 id="系统IO"><a href="#系统IO" class="headerlink" title="系统IO"></a>系统IO</h3><p>系统IO是指通过系统调用将内核空间的数据写入storage层的操作，如下是部分相关的系统IO接口：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">相关函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Open</td>
<td style="text-align:left">open() create()</td>
</tr>
<tr>
<td style="text-align:left">Write</td>
<td style="text-align:left">write() aio_write() pwrite() pwritev()</td>
</tr>
<tr>
<td style="text-align:left">Sync</td>
<td style="text-align:left">fsync() sync()</td>
</tr>
<tr>
<td style="text-align:left">Close</td>
<td style="text-align:left">close()</td>
</tr>
</tbody>
</table>
<h3 id="流式IO"><a href="#流式IO" class="headerlink" title="流式IO"></a>流式IO</h3><p>流式IO是指调用C的运行库中流式接口的IO操作，调用这些函数进行数据写入时可能不会引发系统调用，这意味着数据仍在用户空间中，如下是部分相关的流式IO接口：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>相关函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Open</td>
<td>fopen() fdopen() freopen()</td>
</tr>
<tr>
<td>Write</td>
<td>fwrite() fputc() fputs() puts() putc() putcha()</td>
</tr>
<tr>
<td>Sync</td>
<td>fflush()</td>
</tr>
<tr>
<td>Close</td>
<td>fclose()</td>
</tr>
</tbody>
</table>
<h3 id="内存映射IO"><a href="#内存映射IO" class="headerlink" title="内存映射IO"></a>内存映射IO</h3><p>内存映射文件同前文的系统IO比较相似，文件仍旧是通过相同的接口来打开和关闭，它是通过将文件数据通用户空间映射来实现文件访问，然后执行同其他应用层buffer一样的内存读写操作来读写文件，如下是部分相关的mmap接口：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>相关函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Open</td>
<td>open() create()</td>
</tr>
<tr>
<td>Map</td>
<td>mmap()</td>
</tr>
<tr>
<td>Write</td>
<td>memcpy() memmove() read() 或者其他操作应用层缓存的函数</td>
</tr>
<tr>
<td>Sync</td>
<td>msync()</td>
</tr>
<tr>
<td>Unmap</td>
<td>munmap()</td>
</tr>
<tr>
<td>Close</td>
<td>close()</td>
</tr>
</tbody>
</table>
<p>在打开文件时，有两个选项可以改变时的缓存行为:<code>O_SYNC</code>及<code>O_DIRECT</code>。使用<code>O_DIRECR</code>打开的文件的读写操作会绕过内核空间的<code>page cache</code>,直接将数据写入存储设备中，但是存储设备自身仍可能存在缓存，所以仍旧需要使用<code>fsync()</code>来将数据持久化存储,即<code>O_DIRECR</code>只和系统IO的API相关。裸设备(/dev/raw/raw/V)提供一种特殊的<code>O_DIRECT</code> IO方式，这些设备在打开时不需指定<code>O_DIRECT</code>选项，但仍旧提供<code>direct IO</code>语义。</p>
<p>同步IO是指对于一个使用<code>O_SYNC</code>或者<code>O_DSYNC</code>打开的IO操作（包括不管是否使用了<code>O_DIRECT</code>的系统IO及流式IO），POSIX语义定义了一下几种同步操作模式：</p>
<ul>
<li>O_SYNC：文件数据及所有元数据被同步写入磁盘中</li>
<li>O_DSYNC：只有文件数据及访问该数据需要的元数据需要被同步写入磁盘</li>
<li>O_RSYNC：尚未实现<br>在同步模式下，用户数据及相关的元数据会立马被写入持久化存储设备中，需要注意的是，其他元数据（不涉及到访问该部分数据）可能不会立马被写入持久化设备中，这些元数据可能包括文件的访问时间、创建时间或者修改时间等。<br>另外需要注意使用<code>O_SYNC</code>或<code>O_DSYNC</code> 打开一个文件，然后通过libc的流式接口来操作这个文件的情况，通过<code>fwrite()</code>写入的数据都会被从的运行库缓存，直到调用<code>fflush()</code>后数据才被写入磁盘中。因此，通过此类流式解救操作一个同步文件描述符时，不需要调用<code>fsync()</code>来同步数据，但是<code>fflush()</code>仍旧是必需的。</li>
</ul>
<h2 id="合理使用fsync"><a href="#合理使用fsync" class="headerlink" title="合理使用fsync"></a>合理使用fsync</h2><p>通过如下几条原则来判断是否调用<code>fsync()</code>：</p>
<ul>
<li>首先，将数据持久化存储是否那么重要。如果是可擦洗或可再生的数据，那是没必要的</li>
<li>在创建新文件或者覆盖现有文件时，使用<code>fsync()</code>不止是同步文件数据本身，同时也是同步它的目录项，才能确保之后能访问到这个文件，这个行为同文件系统及挂载选项也是相关的。</li>
<li>最后，如果在覆盖现有文件时系统了奔溃，可能会造成数据的丢失，为了解决这个问题，一个通用做法是先将数据写入一个临时文件，确保这个临时文件持久化存储后将这个临时文件重命名为待覆盖文件名，这样能确保文件的原子更新。相关的流程如下：<ol>
<li>创建一个临时文件</li>
<li>将数据写入临时文件</li>
<li><code>fsync()</code>这个临时文件</li>
<li>将临时文件重命名</li>
<li><code>fsync()</code>文件所在目录</li>
</ol>
</li>
</ul>
<h2 id="写回-write-back-缓存"><a href="#写回-write-back-缓存" class="headerlink" title="写回(write-back)缓存"></a>写回(write-back)缓存</h2><p>本节简单讨论下磁盘层面的缓存以及操作系统对于此种缓存的控制，本节中讨论的选项不影响应用程序该如何构造。<br>存储设备的写回缓存有许多不同的形式，如前文所述的易失性缓存，此类缓存在系统异常时会丢失。在实际中，大部分存储设备都可以被配置为无缓存模式或者写穿(<code>write-through</code>)模式，这些模式在数据被持久化存储之前是不会返回成功给客户端的。此外一些外部存储阵列可能有非易失性缓存或者带电的写入缓存，这样可以在系统掉电时仍旧持久化存储数据。<br>一些文件系统提供控制缓存刷写的挂载选项，例如在2.6.35之后的linux版本中，ext3、ext4及btrfs提供<code>-o barrier</code>这个选项来打开屏障（<code>write-back cache</code>，该选项是默认开的），或者<code>-o nobarrier</code>来关闭它。但是应用层不需要过多考虑这个选项，当文件系统的barriers被禁用后，<code>fsync</code>不会导致磁盘缓存的刷写。</p>
<h2 id="O-DIRECT同O-SYNC的区别"><a href="#O-DIRECT同O-SYNC的区别" class="headerlink" title="O_DIRECT同O_SYNC的区别"></a>O_DIRECT同O_SYNC的区别</h2><p>如前文所述，<code>O_DIRECT</code>可以是IO绕过<code>page cache</code>直达<code>storage层</code>，但是<code>storage</code>层可能仍旧会存在缓存，此时数据仍旧可能是不安全的。但是使用<code>O_DIRECT</code>需要遵守一些限制：</p>
<ul>
<li>用以传递数据的应用层缓存区，其内存边界必须对其块大小的整数倍</li>
<li>数据传输的开始点，即在文件中的偏移值必须也是块大小的整数倍</li>
<li>传输的数据长度必须是块大小的整数倍<br>这些限制都要有应用层来确保，否则会导致EINVAL错误，显而易见的是，使用O_DIRECT容易造成存储空间的浪费</li>
</ul>
<p>而<code>O_SYNC</code>用以将缓存中的数据刷写至磁盘中，此时数据还是会写入<code>page cache</code>中，但是会被立马刷写至磁盘中，直到数据持久化存储才会返回，可以确保数据的安全性。但是通过<code>fsync</code>的manual手册可以看到在一些老的内核或者小众文件系统中，<code>fsync</code>可能不知道如何刷写存储设备的缓存，此时需要别的方式来关闭存储设备的缓存，如下所示：</p>
<p><img src="/images/linux/fsync.png" alt=""></p>
<p>在实际使用过程可以同时使用<code>O_DIRECT</code>及<code>O_DSYNC</code>这个两个选项来确保数据的安全性，这样数据在写入时会直接绕过page cache，持久化存储后才会返回。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://lwn.net/Articles/457667/" target="_blank" rel="noopener">Ensuring data reaches disk</a></li>
<li><a href="https://stackoverflow.com/questions/5055859/how-are-the-o-sync-and-o-direct-flags-in-open2-different-alike" target="_blank" rel="noopener">How are the O_SYNC and O_DIRECT flags in open(2) different/alike</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Leeshine</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/leeshine" target="_blank" title="Github">
                      
                        <i class="fa fa-fw fa-github"></i>Github</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lvshanchun@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leeshine</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
